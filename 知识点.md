### 盒模型
通过box-sizing设置
* content-box 标准模型
    * 宽高不包括边框
* border-box  IE模型
    * 宽高包括边框border和padding

### JS获取宽高
* dom.offsetHeight 最佳
* dom.style.height 只能获取内联样式
* dom.getBoundingClientRect().width/height 根据元素在视窗中的绝对位置来获取宽高的
* window.getComputedStyle(dom).width/height
* dom.currentStyle.width/height  页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。但这种方式只有IE浏览器支持

### BFC 
块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。
[](https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html)
[](https://zhuanlan.zhihu.com/p/25321647)

### 层叠上下文
[](https://juejin.im/post/5b876f86518825431079ddd6)
[](https://juejin.im/post/5b876f86518825431079ddd6#heading-8)

例子：
```
<div >
    <div>

    </div>
</div>
```

层叠上下文的background/border < z-index小于0 < block < float < inline < z-index=0,auto < z-index大于0

如果产生了层叠上下文 那么比较其背景与子元素
没有的话就是普通元素 block

### 居中布局

[flex](https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/)


.parent {
    display: flex;
    justify-content: center;
}

.parent {
    display: flex;
    align-items: center;
}


* 水平居中

    * 行内元素: text-align: center
    * 块级元素: margin: 0 auto
    * absolute + transform
    * flex + justify-content: center


* 垂直居中

    * line-height: height
    * absolute + transform
    * flex + align-items: center
    * table <table> <tr> <td>12 </td> </tr> </table>



* 水平垂直居中

    * absolute + transform
    * flex + justify-content + align-items
    * fixed margin:auto left:0 right:0 right:0 bottom：0


### 选择器优先级

!important > 内联样式 > id > class(属性选择器[]、伪类 :) > 标签(伪元素) > 通用选择器 > 继承 > 默认

后定义的优先级较高


[css选择器参考](./选择器.md)

### 去除浮动影响，防止父级高度塌陷
```
<div class="outer">
  <div class="inner">1</div>
  <div class="inner">2</div>
  <div class="inner">3</div>
</div>
```

* 通过增加尾元素清除浮动 :after / <br> : clear: both
    * clear:both 左右两侧均不能出现浮动元素

(::after 是css3提出的 和 :after相同 ，都是伪元素，作为已选中元素的最后一个子元素。为了兼容性 建议使用:after)
```
#clear{
  clear: both;
}

<div class="outer">
  <div class="inner">1</div>
  <div class="inner">2</div>
  <div class="inner">3</div>
  <div id="clear"></div>
</div>

```

```

```

* 创建父级 BFC 

```
.outer{
    overflow:hidden;
}
```
* 父级设置高度


### <link> 与 @import 的区别
* link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css
<link rel="stylesheet" href="****.css" type="text/css">
@import "***.css"
* 当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载
* @import需要 IE5 以上才能使用
* link可以使用 js 动态引入，@import不行

### CSS预处理器(Sass/Less/Postcss)
* Less
* Sass
* postCSS

[less](https://juejin.im/post/5a2bc28f6fb9a044fe464b19)

### css动画
* transition 
    * transition-property: 产生动画效果的属性
    * transition-duration: 动画时间
    * transition-timing-function: 曲线 [设置运动曲线](http://cubic-bezier.com/#.17,.67,.83,.67)
    * transition-delay: 延迟 用于设计动画发生的顺序

transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态

#### transition的优点在于简单易用，但是它有几个很大的局限。
* transition需要事件触发，所以没法在网页加载时自动发生。
* transition是一次性的，不能重复发生，除非一再触发。
* transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。

常用钩子: transitionend

* animation
   * animation-name: 动画名称，对应@keyframes
    * 动画属性
        * translate 
        * scale 
        * rotate 旋转
        * skew 倾斜转换
        * opacity
        * color
   * animation-duration: 间隔
   * animation-timing-function: 
        * 曲线 cubic-bezier()
        * steps(number,position) 让动画不连续
            * number 动画分成几段
            * position ： start （从下一个阶段开始） end （从初始状态开始）
            [例子](./transition.html)
   * animation-delay: 延迟
   * animation-iteration-count: 次数
        * infinite: 循环动画
   * animation-direction: 方向
        * alternate: 交替播放
        * reverse ：反向播放
        * alternate-reverse 
   * animation-fill-mode: 静止模式
        * forwards: 停止时，保留最后一帧
        * backwards: 停止时，回到第一帧
        * both: 同时运用 forwards / backwards
    * animation-play-state 没有鼠标没有悬停时，动画状态是暂停；一旦悬停，动画状态改为继续播放

    ```
    div {
        animation: spin 1s linear infinite;
        animation-play-state: paused;
    }

    div:hover {
        animation-play-state: running;
    }
    ```

```
.my-boat{
    animation :1s run;
}

@keyframe run{
    0% { background: #c00; }
    50% { background: orange; }
    100% { background: yellowgreen; }
}
```

### 原型链
[原型/原型链/创建/继承](./js继承.md)
* 原型链是由原型对象组成，每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型，__proto__ 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。


    * 属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined；


    * 属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。




### 执行环境(执行上下文) EC 
* 全局执行环境 最外围的执行环境
* 函数执行环境
* eval执行环境 可以把调用上下文作为第二个参数传递给 eval


* 变量对象 VO
    * 每一个执行环境都有一个与之相关联的变量对象
    * 其中保存着环境中所定义的 变量 和 函数
* 活动对象 AO

* 全局执行环境 window对象
* 每个函数都有自己的执行环境

#### this指向
函数运行时所在的环境
[原理上解释this指向 看底下评论](https://github.com/mqyqingfeng/Blog/issues/7) 还没看懂
[简单解释](http://www.ruanyifeng.com/blog/2018/06/javascript-this.html)

#### 作用域链
执行上下文中包含作用域链。指向变量对象的指针列表
当代码在**一个环境中**执行时，会创建变量对象的**一个作用域链**，变量对象激活了变成活动对象
* [[ scope ]] 指向父级变量对象和作用域链
* 自身活动对象
#### 代码执行过程:

* 创建 全局上下文 (global EC)
* 全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被* push到执行栈顶层
* 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起
* 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行
* 执行到最后，执行环境栈中只有全局执行上下文，等到应用程序结束才会销毁

### 作用域
上下文中声明的 变量和声明的作用范围
* 全局作用域 不带有声明关键字的变量，JS 会默认帮你声明一个全局变量
* 块级作用域 用let声明 const （es6） 是必须有一个 { } 包裹：
```
for(let i = 0; i < 5; i++) {
    setTimeout(function() {
      console.log(i);
    }, 200);
};
//for (let x...)的循环在每次迭代时都为x创建新的绑定 相当于下面的例子
var a = [];
{ var k;
    for (k = 0; k < 10; k++) {
      let i = k; //注意这里，每次循环都会创建一个新的i变量
      a[i] = function () {
        console.log(i);
      };
    }
}
```
上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域

* 函数作用域
* 词法作用域 [](https://github.com/mqyqingfeng/Blog/issues/3) 当我们要使用声明的变量时：JS引擎总会从最近的一个域，向外层域查找；
* 动态作用域 动态作用域，作用域是基于调用栈的，而不是代码中的作用域嵌套；
    * js是词法作用域 除了this引用

#### 特性
* 声明提前: 一个声明在函数体内都是可见的, 函数优先于变量
    * var 变量的声明会提前 赋值不会
    * let 声明的变量不会提前。let 声明的变量不能在声明之前被使用，在作用域里定义赋值之前的部分会对该变量形成一个“暂时性死区”，也就是认为该变量不存在，也不可使用。在死区内使用该变量就会报错——即，后两个题目都会报错
    * 函数的声明 
        * 匿名函数 赋值式声明 定义（var a =function(){} (){}） 声明和定义不会提前
        * 非赋值非匿名式声明定义，（function a（）{}）声明和定义都会提前
* 非匿名自执行函数，函数变量 为 只读 状态，无法修改 ？？？

### 闭包
[闭包实现原理](https://www.zhihu.com/question/36393048)
闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，**除了this和arguments**这样的函数称为闭包。


* 多个子函数的[[scope]]都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。
    * 变量可以通过 函数参数的形式 传入，避免使用默认的[[scope]]向上查找 
        * (function(msg){
            return function(){console.log(msg);}
        })(i)
    * 使用setTimeout包裹，通过第三个参数传入
        * 第三个参数及以后的参数都可以作为func函数的参数
    
    * 使用 块级作用域，让变量成为自己上下文的属性，避免共享
        for(let i;i<3;i++)
```
function setData(){
    var data = [];
    for(var i=0;i<3;i++){
        data[i] = (function(i){
            return function(){
                 console.log(i);
            }
        })(i);             
    }
    return data;
}
var data = setData();
data[1]();

for (var i = 0; i < 3; i++) {
  setTimeout((msg)=>{
    data[msg] = function(){
        console.log(msg);
    }
  },0,i)
}
```

> (function(){})() function外面的括号是将函数声明转化为函数表达式，所以才可以立即执行
    
#### 模仿块级作用域
 (function(){
     //这里是块级作用域
 })()

 ### script 引入方式
 * html 静态<script>引入
 * js 动态插入<script>
 ```
 function loadScript(url){
            var script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = url;
            document.body.appendChild(script);
        }
loadScript('test.js');

function loadJsCode(code){
    var script = document.createElement('script');
    script.type = 'text/javascript';
    //for Chrome Firefox Opera Safari
    script.appendChild(document.createTextNode(code));
    //for IE
    //script.text = code;
    document.body.appendChild(script);
}
loadJsCode('alert(2)');

 ```
 
 * `<script defer>`:异步加载，元素解析完成后执行,但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成
 * `<script async>`: 异步加载，但执行时会阻塞元素渲染  下载完后立即执行
 * 没有这两个标签 浏览器会在遇到js代码就立即执行，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。
    * 两者都会并行下载，不会影响页面的解析 defer会在元素渲染完之后执行 ，async下载完后立即执行

###  对象的拷贝

#### 普通的一个个复制属性
```
for(key in obj){
    newobj[key] = obj[key];
}
```
* objCopy 对象具有一个新的 Object.prototype方法，这与 mainObj 对象的原型方法不同，这不是我们想要的。我们需要精确的拷贝原始对象。
* 属性描述符不能被复制。值为 false 的 “可写(writable)” 描述符在 objCopy 对象中为 true 。
* 上面的代码只复制了 mainObj 的可枚举属性。
* 如果原始对象中的一个属性本身就是一个对象，那么副本和原始对象之间将共享这个对象，从而使其各自的属性指向同一个对象。

#### 浅拷贝
* Object.assigh(目标对象，源对象..) 返回目标对象
    * Object.assign() 方法用于将从一个或多个源对象中的所有可枚举的属性值复制到目标对象
    * 可以用于复制对象的方法
    * 原型链上的属性和不可枚举的属性不能复制  
    * 属性的值为对象 依旧只是引用
* 展开运算符 ...
    * 对象展开运算符让你可以通过展开运算符 (...) , 以更加简洁的形式将一个对象的可枚举属性拷贝至另一个对象
    * 对象字面量的展开操作符能将源对象中的可枚举的属性复制到目标对象上

```
let obj = {
  one: 1,
  two: 2,
}
 
let newObj = { ...z };
 
var x =[1,2,3];
var y = [...x];
```

#### 深拷贝
* 使用 JSON.parse(JSON.stringify(object)); 
    * 具有循环引用的对象时，报错
    * 当值为函数、undefined、或symbol时，无法拷贝
* 递归进行逐一赋值
