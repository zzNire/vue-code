### 盒模型
通过box-sizing设置
* content-box 标准模型
    * 宽高不包括边框
* border-box  IE模型
    * 宽高包括边框border和padding

### JS获取宽高
* dom.offsetHeight 最佳
* dom.style.height 只能获取内联样式
* dom.getBoundingClientRect().width/height 根据元素在视窗中的位置来获取宽高的 
* window.getComputedStyle(dom).offsetWidth/height 获得最后显示的css样式
* dom.currentStyle.width/height  页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。但这种方式只有IE浏览器支持


* offsetWidth 相对于父元素偏移量 = content+padding2+border2
* clientWidth 客户去大小 content + padding*2
* scrollWidth 滚动大小 包括滚动条
### BFC 
块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。
[](https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html)
[](https://zhuanlan.zhihu.com/p/25321647)

### 层叠上下文
[](https://juejin.im/post/5b876f86518825431079ddd6)
[](https://juejin.im/post/5b876f86518825431079ddd6#heading-8)

例子：
```
<div >
    <div>

    </div>
</div>
```

层叠上下文的background/border < z-index小于0 < block < float < inline < z-index=0,auto < z-index大于0

如果产生了层叠上下文 那么比较其背景与子元素
没有的话就是普通元素 block

### 居中布局

[flex](https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/)


.parent {
    display: flex;
    justify-content: center;
}

.parent {
    display: flex;
    align-items: center;
}


* 水平居中

    * 行内元素: text-align: center
    * 块级元素: margin: 0 auto
    * absolute + transform
    * flex + justify-content: center


* 垂直居中

    * line-height: height
    * absolute + transform
    * flex + align-items: center
    * table <table> <tr> <td>12 </td> </tr> </table>



* 水平垂直居中

    * absolute + transform
    * flex + justify-content + align-items
    * fixed margin:auto left:0 right:0 right:0 bottom：0


### 选择器优先级

!important > 内联样式 > id > class(属性选择器[]、伪类 :) > 标签(伪元素) > 通用选择器 > 继承 > 默认

后定义的优先级较高


[css选择器参考](./选择器.md)

### 去除浮动影响，防止父级高度塌陷
```
<div class="outer">
  <div class="inner">1</div>
  <div class="inner">2</div>
  <div class="inner">3</div>
</div>
```

* 通过增加尾元素清除浮动 :after / <br> : clear: both
    * clear:both 左右两侧均不能出现浮动元素

(::after 是css3提出的 和 :after相同 ，都是伪元素，作为已选中元素的最后一个子元素。为了兼容性 建议使用:after)
```
#clear{
  clear: both;
}

<div class="outer">
  <div class="inner">1</div>
  <div class="inner">2</div>
  <div class="inner">3</div>
  <div id="clear"></div>
</div>

```

```

```

* 创建父级 BFC 

```
.outer{
    overflow:hidden;
}
```
* 父级设置高度


### <link> 与 @import 的区别
* link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css
<link rel="stylesheet" href="****.css" type="text/css">
@import "***.css"
* 当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载
* @import需要 IE5 以上才能使用
* link可以使用 js 动态引入，@import不行

### CSS预处理器(Sass/Less/Postcss)
* Less
* Sass
* postCSS

[less](https://juejin.im/post/5a2bc28f6fb9a044fe464b19)

### css动画
* transition 
    * transition-property: 产生动画效果的属性
    * transition-duration: 动画时间
    * transition-timing-function: 曲线 [设置运动曲线](http://cubic-bezier.com/#.17,.67,.83,.67)
    * transition-delay: 延迟 用于设计动画发生的顺序

transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态

#### transition的优点在于简单易用，但是它有几个很大的局限。
* transition需要事件触发，所以没法在网页加载时自动发生。
* transition是一次性的，不能重复发生，除非一再触发。
* transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。

常用钩子: transitionend

* animation
   * animation-name: 动画名称，对应@keyframes
    * 动画属性
        * translate 
        * scale 
        * rotate 旋转
        * skew 倾斜转换
        * opacity
        * color
   * animation-duration: 间隔
   * animation-timing-function: 
        * 曲线 cubic-bezier()
        * steps(number,position) 让动画不连续
            * number 动画分成几段
            * position ： start （从下一个阶段开始） end （从初始状态开始）
            [例子](./transition.html)
   * animation-delay: 延迟
   * animation-iteration-count: 次数
        * infinite: 循环动画
   * animation-direction: 方向
        * alternate: 交替播放
        * reverse ：反向播放
        * alternate-reverse 
   * animation-fill-mode: 静止模式
        * forwards: 停止时，保留最后一帧
        * backwards: 停止时，回到第一帧
        * both: 同时运用 forwards / backwards
    * animation-play-state 没有鼠标没有悬停时，动画状态是暂停；一旦悬停，动画状态改为继续播放

    ```
    div {
        animation: spin 1s linear infinite;
        animation-play-state: paused;
    }

    div:hover {
        animation-play-state: running;
    }
    ```

```
.my-boat{
    animation :1s run;
}

@keyframe run{
    0% { background: #c00; }
    50% { background: orange; }
    100% { background: yellowgreen; }
}
```

### 原型链
[原型/原型链/创建/继承](./js继承.md)
* 原型链是由原型对象组成，每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型，__proto__ 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。


    * 属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined；


    * 属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。




### 执行环境(执行上下文) EC 
* 全局执行环境 最外围的执行环境
* 函数执行环境
* eval执行环境 可以把调用上下文作为第二个参数传递给 eval


* 变量对象 VO
    * 每一个执行环境都有一个与之相关联的变量对象
    * 其中保存着环境中所定义的 变量 和 函数
* 活动对象 AO

* 全局执行环境 window对象
* 每个函数都有自己的执行环境

#### this指向
函数运行时所在的环境
[原理上解释this指向 看底下评论](https://github.com/mqyqingfeng/Blog/issues/7) 还没看懂
[简单解释](http://www.ruanyifeng.com/blog/2018/06/javascript-this.html)

由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是this。
因此要明白 this 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如:

* obj.fn()，便是 obj 调用了函数，既函数中的 this === obj
* fn()，这里可以看成 window.fn()，因此 this === window

但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 this 的指向:

* call: fn.call(target, 1, 2)
* apply: fn.apply(target, [1, 2])
* bind: fn.bind(target)(1,2) 返回新函数 其中this指向target



#### 作用域链
执行上下文中包含作用域链。指向变量对象的指针列表
当代码在**一个环境中**执行时，会创建变量对象的**一个作用域链**，变量对象激活了变成活动对象
* [[ scope ]] 指向父级变量对象和作用域链
* 自身活动对象
#### 代码执行过程:

* 创建 全局上下文 (global EC)
* 全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被* push到执行栈顶层
* 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起
* 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行
* 执行到最后，执行环境栈中只有全局执行上下文，等到应用程序结束才会销毁

### 作用域
上下文中声明的 变量和声明的作用范围
* 全局作用域 不带有声明关键字的变量，JS 会默认帮你声明一个全局变量
* 块级作用域 用let声明 const （es6） 是必须有一个 { } 包裹：
    * let 没有变量提升 不能重复定义
```
for(let i = 0; i < 5; i++) {
    setTimeout(function() {
      console.log(i);
    }, 200);
};
//for (let x...)的循环在每次迭代时都为x创建新的绑定 相当于下面的例子
var a = [];
{ var k;
    for (k = 0; k < 10; k++) {
      let i = k; //注意这里，每次循环都会创建一个新的i变量
      a[i] = function () {
        console.log(i);
      };
    }
}
```
上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域

* 函数作用域
* 词法作用域 [](https://github.com/mqyqingfeng/Blog/issues/3) 当我们要使用声明的变量时：JS引擎总会从最近的一个域，向外层域查找；
* 动态作用域 动态作用域，作用域是基于调用栈的，而不是代码中的作用域嵌套；
    * js是词法作用域 除了this引用

#### 特性
* 声明提前: 一个声明在函数体内都是可见的, 函数优先于变量
    * var 变量的声明会提前 赋值不会
    * let 声明的变量不会提前。let 声明的变量不能在声明之前被使用，在作用域里定义赋值之前的部分会对该变量形成一个“暂时性死区”，也就是认为该变量不存在，也不可使用。在死区内使用该变量就会报错——即，后两个题目都会报错
    * 函数的声明 
        * 匿名函数 赋值式声明 定义（var a =function(){} (){}） 声明和定义不会提前
        * 非赋值非匿名式声明定义，（function a（）{}）声明和定义都会提前
* 非匿名自执行函数，函数变量 为 只读 状态，无法修改 ？？？

### 闭包
[闭包实现原理](https://www.zhihu.com/question/36393048)
闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，**除了this和arguments**这样的函数称为闭包。


* 多个子函数的[[scope]]都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。
    * 变量可以通过 函数参数的形式 传入，避免使用默认的[[scope]]向上查找 
        * (function(msg){
            return function(){console.log(msg);}
        })(i)
    * 使用setTimeout包裹，通过第三个参数传入
        * 第三个参数及以后的参数都可以作为func函数的参数
    
    * 使用 块级作用域，让变量成为自己上下文的属性，避免共享
        for(let i;i<3;i++)
```
function setData(){
    var data = [];
    for(var i=0;i<3;i++){
        data[i] = (function(i){
            return function(){
                 console.log(i);
            }
        })(i);             
    }
    return data;
}
var data = setData();
data[1]();

for (var i = 0; i < 3; i++) {
  setTimeout((msg)=>{
    data[msg] = function(){
        console.log(msg);
    }
  },0,i)
}
```

> (function(){})() function外面的括号是将函数声明转化为函数表达式，所以才可以立即执行
    
#### 模仿块级作用域
 (function(){
     //这里是块级作用域
 })()

 ### script 引入方式
 * html 静态<script>引入
 * js 动态插入<script>
 ```
 function loadScript(url){
            var script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = url;
            document.body.appendChild(script);
        }
loadScript('test.js');

function loadJsCode(code){
    var script = document.createElement('script');
    script.type = 'text/javascript';
    //for Chrome Firefox Opera Safari
    script.appendChild(document.createTextNode(code));
    //for IE
    //script.text = code;
    document.body.appendChild(script);
}
loadJsCode('alert(2)');

 ```
 
 * `<script defer>`:异步加载，元素解析完成后执行,但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成
 * `<script async>`: 异步加载，但执行时会阻塞元素渲染  下载完后立即执行
 * 没有这两个标签 浏览器会在遇到js代码就立即执行，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。
    * 两者都会并行下载，不会影响页面的解析 defer会在元素渲染完之后执行 ，async下载完后立即执行

###  对象的拷贝

#### 普通的一个个复制属性
```
for(key in obj){
    newobj[key] = obj[key];
}
```
* objCopy 对象具有一个新的 Object.prototype方法，这与 mainObj 对象的原型方法不同，这不是我们想要的。我们需要精确的拷贝原始对象。
* 属性描述符不能被复制。值为 false 的 “可写(writable)” 描述符在 objCopy 对象中为 true 。
* 上面的代码只复制了 mainObj 的可枚举属性。
* 如果原始对象中的一个属性本身就是一个对象，那么副本和原始对象之间将共享这个对象，从而使其各自的属性指向同一个对象。

#### 浅拷贝
* Object.assigh(目标对象，源对象..) 返回目标对象
    * Object.assign() 方法用于将从一个或多个源对象中的所有可枚举的属性值复制到目标对象
    * 可以用于复制对象的方法
    * 原型链上的属性和不可枚举的属性不能复制  
    * 属性的值为对象 依旧只是引用
* 展开运算符 ...
    * 对象展开运算符让你可以通过展开运算符 (...) , 以更加简洁的形式将一个对象的可枚举属性拷贝至另一个对象
    * 对象字面量的展开操作符能将源对象中的可枚举的属性复制到目标对象上

```
let obj = {
  one: 1,
  two: 2,
}
 
let newObj = { ...z };
 
var x =[1,2,3];
var y = [...x];
```

#### 深拷贝
* 使用 JSON.parse(JSON.stringify(object)); 
    * 具有循环引用的对象时，报错
    * 当值为函数、undefined、或symbol时，无法拷贝
* 递归进行逐一赋值

### 原型和实例的关系
* instanceof 原型链中出现过的**构造函数** 返回true
* isPrototypeOf(实例) 原型链中出现的**原型** 返回true

### new运算符的执行过程
* 生成新对象
* 链接到原型 新对象.`_proto_` = 对象.prototype 
* 绑定this 指向新对象
* 返回新对象 

### 代码复用 
* 函数封装
* 继承
* extends继承（es6）  class A extends B
* 复制extend  
    * 使用jQuery的$.extend({},a) 浅拷贝
    * $.extend(true,{},a); 深复制
    * Undersource  _.extend()
 
* 混入mixin 一种模式  
    * 如果一个对象需要使用其他多个对象已经定义的"功能"的时候，我们就可以使用mixins复用代码
    * 一个对象的属性拷贝到另一个对象上面去
* 借用apply/call

（for-of 遍历数组值）

### 类型转换 
大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:

* -、*、/、% ：一律转换成数值后计算
* +：

    * 数字 + 字符串 = 字符串， 运算顺序是从左到右
    * 数字 + 对象， 优先调用对象的valueOf -> toString
    * 数字 + boolean/null -> 数字
    * 数字 + undefined -> NaN
* [1].toString() === '1'
* {}.toString() === '[object object]'
* NaN !== NaN 、+undefined 为 NaN

### 类型检查 
* typeof （number boolean object function string undefined）
    * NaN 的数据类型是 number
    * 数组(Array)的数据类型是 object
    * 日期(Date)的数据类型为 object
    *  **null 的数据类型是 object**  String(null) 来判断
    * 未定义变量的数据类型为 undefined
* instanceof （Array Date RegExp Object）
* constructor 返回构造函数
* Object.prototype.toString() 返回[Object XXX] 来判断

```
let class2type = {}
'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase()) 

function type(obj) {
    if (obj == null) return String(obj)
    return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj
}
```

### 模块化
* ES6 ：export import 值是动态绑定的 
    * 静态化 先于模块内其他语句执行，命令具有提升效果
    * export输出文件内部变量、函数、类 export {a,b as B,c}; import {a,B,c} from ' '
    * export default  为模块指定默认输出， 一个模块只能有一个默认输。本质上，export default就是输出一个叫做default的变量或方法 
        * export default a; import a from ' '
    * import  命令具有提升效果
        * import * from "" 模块的整体加载，加载文件中全部的export 
    * import() 函数 动态加载 返回一个 Promise 对象
        * 加载模块成功以后，这个模块会作为一个对象，当作then方法的参数
    例如：
```
//输出单个变量
var name = nirean;
export {name}

//输出一组变量
var name = nirean;
bar age = 22;
function getHabby(){

};
export {name , age, geyHabby};

//as 重命名
export {name as myname};

// circle.js输出两个函数 import * 整体加载
 
export function area(radius) {
  return Math.PI * radius * radius;
}

export function circumference(radius) {
  return 2 * Math.PI * radius;
}

import * as circle from './circle';

console.log('圆面积：' + circle.area(4));
console.log('圆周长：' + circle.circumference(14));

// export default 不需要{ }
export default getName;
import getName from '...';

// export default 为模块指定默认输出
export default function(){};
import getName from '...';
```

* NodeJS中的commonJS ：**require exports module.exports**
    * CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作 不适合浏览器
    * require()用来引入外部模块； 
        * 读入并执行一个JavaScript文件，然后返回该模块的exports对象
        * 第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性
    * exports对象用于导出当前模块的方法或变量，唯一的导出口；
    * module.export nodeJS仅仅为了方便，用了一个变量exports直接指向了module.exports了
    * module对象就代表模块本身。
* AMD define

```
module.exports.x = x;  var y = require(""); y.x
module.exports = x; var y = require(""); y
module.exports = {x:x}; var y = require(""); y.x
```
### require与import的区别
* require支持 动态导入（地址中包含变量），import 不支持，正在提案 (babel 下可支持) ->import()
* require是 同步 导入，import属于 异步 导入
* require是 值拷贝，导出值变化不会影响导入值；import指向 内存地址，导入值会随导出值而变化


### 同步 异步
* 同步 
    * 如果在函数返回的时候，调用者就能够得到预期结果
    * 如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。
* 异步
    * 如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。
    * 如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。

### 防抖与节流
#### 防抖 (debounce)
将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可
```
function debounce(fn, wait, immediate) {
    let timer = null

    return function() {
        let args = arguments
        let context = this

        if (immediate && !timer) {
            fn.apply(context, args)
        }

        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(context, args)
        }, wait)
    }
}

```

#### 节流(throttle)
每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可
```
function throttle(fn, wait, immediate) {
    let timer = null
    let callNow = immediate
    
    return function() {
        let context = this,
            args = arguments

        if (callNow) {
            fn.apply(context, args)
            callNow = false
        }

        if (!timer) {
            timer = setTimeout(() => {
                fn.apply(context, args)
                timer = null
            }, wait)
        }
    }
}

```

### AST 抽象语法树
将代码逐字母解析成 树状对象 的形式


### babel编译原理
* babylon 将 ES6/ES7 代码解析成 AST
* babel-traverse 对 AST 进行遍历转译，得到新的 AST
* 新 AST 通过 babel-generator 转换成 ES5


### 函数柯里化 
在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。
```
const add = function add(x) {
	return function (y) {
		return x + y
	}
}

const add1 = add(1)

add1(2) === 3
add1(20) === 21
```

### Array
#### 数组乱序
```
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.sort(function () {
    return Math.random() - 0.5;
});
```

#### 数组解析 
[1,[2,3]] --> [1, 2, 3]
```
Array.prototype.flat = function() {
    return this.toString().split(',').map(item => item-0 )
}
```

### Promise
* new Promise直接执行，返回Promise对象
new Promise((resolve,reject)=>{
    if(successed)
    {
        resolve(value); //成功返回结果
    }
    else{
        reject(error);  //失败返回错误信息
    }
}).then((value)=>{
    // 成功的回调函数
},
(error)=>{

})
----------------------------------------------------------------
### 跨标签页通讯
#### postMessage 子页面
* 父页面 通过 window.open() 或 iframe标签 打开子页面
* 子页面对象调用 postMessage(msg,targetOrigin)发送消息
    * targetOrigin 表示可以获得**该消息所在的域**也可以设置为"*"，表示任何域名都可取得消息
* 子页面中，通过window.addEventListener("message",(evt)=>{},false)取得消息
    * evt中 data为传递的消息 

#### localStorage 同源
* localstorage是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信(ps：session是会话级的存储空间，每个标签页都是单独的）。
* 直接在window对象上添加监听即可：
* onstorage以及storage事件，针对都是非当前页面对localStorage进行修改时才会触发，当前页面修改localStorage不会触发监听函数。然后就是在对原有的数据的值进行修改时才会触发，比如原本已经有一个key会a值为b的localStorage，你再执行：localStorage.setItem('a', 'b')代码，同样是不会触发监听函数的

```
window.onstorage = (e)=>{}

window.addEventListener('storage',fn);
```
#### 定时器setInterval+cookie 同域 
* document.cookie = 改变cookie的值
* setInterval(getcookie(),100);

#### html5浏览器的新特性SharedWorker 
* 普通的webworker直接使用new Worker()即可创建，这种webworker是当前页面专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的。
* SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)


#### webSocket
在浏览器和服务器之间建立一个不受限的双向通信的通道
WebSocket连接必须由浏览器发起，特点：
1. 建立在 TCP 协议之上，服务器端的实现比较容易。
2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
3. 数据格式比较轻量，性能开销小，通信高效。
4. 可以发送文本，也可以发送二进制数据。
5. 没有同源限制，客户端可以与任意服务器通信。
6. 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。


### 浏览器架构
* 用户界面
* 主进程
* 内核
    * 渲染引擎
    * JS引擎
        * 执行栈
    * 事件触发线程
        * 消息队列
            * 微任务
            * 宏任务
    * 网络异步线程
    * 定时器线程

### 浏览器下事件循环(Event Loop)
事件循环是指: 当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出**一个事件**。同一次事件循环中，微任务永远在宏任务之前执行

，清空微任务列表，执行一个宏任务，循环再清微任务列表，再执行宏任务，

* 一个线程中，事件循环是唯一的，但是任务队列可以拥有多个
* setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。
* 来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。

* 微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃)
* 宏任务 macrotask(task): setTimout / script（整体代码） / IO（有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O） / UI Rendering（页面渲染）/ 
    * 宏任务优先级 优先执行冒泡的事件


### 从输入 url 到展示的过程
* DNS 解析 域名 -> ip
* TCP 三次握手
* 发送请求，分析 url，设置请求报文(头，主体)
* 服务器返回请求的文件 (html)
* 浏览器渲染
    * HTML parser --> DOM Tree
        * 标记化算法，进行元素状态的标记
        * dom 树构建
    * CSS parser --> Style Tree
        * 解析 css 代码，生成样式树
    * attachment --> Render Tree
        * 结合 dom树 与 style树，生成渲染树
    * layout: 布局
    * GPU painting: 像素绘制页面

### 重绘与回流
当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。

* 重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少

* 回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:
    * 页面初次渲染
    * 浏览器窗口大小改变
    * 元素尺寸、位置、内容发生改变
    * 元素字体大小变化
    * 添加或者删除可见的 dom 元素
    * 激活 CSS 伪类（例如：:hover）
    * 查询某些属性或调用某些方法
        * clientWidth、clientHeight、clientTop、clientLeft
        * offsetWidth、offsetHeight、offsetTop、offsetLeft
        * scrollWidth、scrollHeight、scrollTop、scrollLeft
        * getComputedStyle()
        * getBoundingClientRect()
        * scrollTo()

#### 最佳实践:


* css
    * 避免使用table布局 
    * 将动画效果应用到position属性为absolute或fixed的元素上

* javascript
    * 避免频繁操作样式，可汇总后统一 一次修改
*   * 尽量使用class进行样式修改
    * 减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入
    * 极限优化时，修改样式可将其display: none后修改
    * 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住


### 存储
* 短暂性的时候，我们只需要将数据存在内存中，只在运行时可用

* 持久性存储，可以分为 浏览器端 与 服务器端

    * 浏览器:
        * cookie: 通常用于存储用户身份，登录状态等
            * document.cookie = 
            * http 中自动携带， 体积上限为 4K， 可自行设置过期时间
        * localStorage / sessionStorage: 长久储存/窗口关闭删除
            * 体积限制为 4~5M
            * localStorage.setItem(key,value) 存储自动转化为字符串
        * indexDB
    * 服务器:
        * 分布式缓存 redis
        * 数据库

### Web Worker
现代浏览器为JavaScript创造的 多线程环境。可以新建并将部分任务分配到worker线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。

* Worker 线程一旦新建成功，就会始终运行
1. 同源限制

分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

2. DOM 限制

Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。

3. 通信联系

Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

4. 脚本限制

Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

5. 文件限制

Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。

* 主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程