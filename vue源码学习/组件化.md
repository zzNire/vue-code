## creayeElement -> createComponent 生成Vnode
1. 根据tag类型，如果不是string，则调用`createComponent() `
> tag 是`createElement`函数的第一个参数，由`render: h => h(App),`，这里例子中为App对象
2. 以Vue为源，复制生成一个Sub对象(VueComponent)，再调用`extend`方法扩展Sub对象，包括Vue上的静态方法，继承Vue的原型，cid，options，生命周期的钩子函数
3. 再以Sub对象为参数生成Vnode（占位符Vnode）

## _update 生成 dom
1. `__patch__ -> createElm`
2. `if(createComponent())` 判断是否是组件vnode
    * true 直接结束
        * 执行`data.hook.init(componentVNodeHooks->init)->this._init` -> 生成新Vue实例child -> child调用`$mount` 重复上述步骤1
    * false 继续执行`createEle`
        * 创建dom
        * `createChildren`
            * 重复步骤1
        * `insert` 将生成的节点插入parent节点中

> `vm.$vnode` 表示占位符,也就是父Vnode `vm._vnode` 表示渲染vnode

> `activeInstance` 作用就是保持当前上下文的 Vue 实例

## 配置合并
* 对于通过`Vue.mixin()`方法定义在Vue上的属性，会直接调用 `MergeOptions()`
* 对于`new Vue()`实例中，执行`_init`方法会进行配置合并
    * 普通的Vue实例，调用  `MergeOptions()`
        * `mergeField()` 根据不同的配置，会提供不同的合并策略
    * 组件，调用  `initInternalComponent()`
* 子组件的配置合并
    * 子组件在复制Vue生成Sub时,会调用`MergeOpetions()`合并Vue上的options和组件的`extendoptions`（也就是组件exports default抛出的内容）到 `Sub.options`
    * 在实例化子组件Vue实例时，会执行`_init()`方法，调用 `initInternalComponent()`
        * 合并Sub上定义的options，只是做了简单一层对象赋值，并不涉及到递归、合并策略等复杂逻辑。
        * 复制 `{_isComponent: true,_parentVnode: vnode,parent: parent}`


## 组件注册
* 全局注册
    * 通过`Vue.component('app',App)`注册全局组件,该方法会为组件建立一个VueComponent构造器，保存在全局 Vue.options.components中，在后面createElement用到该组件时，会从其中查找
    * 每个组件的创建都是通过 Vue.extend 继承而来，会把 Vue.options 合并到Sub.options，在组件的实例化阶段，会执行 merge options 逻辑，把 Sub.options.components 合并到 vm.$options.components 上。所以在其他组件中通过resolveAsset()找到全局组件的构造器，也可以使用全局组件。
* 局部注册
    * 形式如下
    * Vue 的实例化阶段`initInternalComponent()`合并 option 的逻辑,所以就把 components 合并到 vm.$options.components 上 (vm是局部的组件vue实例)

```js
export default {
  name: 'app',
  components: {
    HelloWorld
  },
}
```

## 异步组件
#### 工厂函数
```js
Vue.component('app',function(resolve,reject){
  require(["./App.vue"],resolve);
})
```
1. 通过`Vue.component('app',App)`注册全局组件，会直接把工厂函数保存在Vue.options.components中
2. 在执行到  createELement -> createComponent,因为他是一个工厂函数，而不是VueComponent构造器，所以执行resolveAsyncComponent()
3. 其中会设置 resolve方法，`const res = factory(resolve, reject)`,
4. 创建一个空vnode，在html节点中插入注释节点
5. 在异步组件加载完成后，执行resolve函数，触发 当前vm 的 watcher 的 update方法，渲染异步组件

#### 返回一个 Promise
```js
Vue.component('async-webpack-example',
  // 这个 `import` 函数会返回一个 `Promise` 对象。
  () => import('./my-async-component')
})
```
1. 同上，通过`Vue.component('app',App)`注册全局组件，会直接把工厂函数保存在Vue.options.components中
2. 在执行到  createELement -> createComponent,因为他是一个工厂函数，而不是VueComponent构造器，所以执行resolveAsyncComponent()
3. 设置resolve方法，执行`const res = factory(resolve, reject)`,由于返回的res是一个promise对象，所以会设置promise的then回调函数，`res.then(resolve, reject)`来执行设定的resolve方法。
4. 同上，创建一个空vnode，在html节点中插入注释节点
5. 同上，在异步组件加载完成后，执行resolve函数，执行forceRender =>触发 当前vm 的 watcher 的 update方法，渲染异步组件

#### 高级异步组件
```js
const LoadingComponent  = {
    template:'<div>loading</div>'
}

const ErrorComponent  = {
    template:'<div>error</div>'
}

const AsyncComponent = () => ({
  // 需要加载的组件 (应该是一个 `Promise` 对象)
  component: import('./MyComponent.vue'),
  // 异步组件加载时使用的组件
  loading: LoadingComponent,
  // 加载失败时使用的组件
  error: ErrorComponent,
  // 展示加载时组件的延时时间。默认值是 200 (毫秒)
  delay: 200,
  // 如果提供了超时时间且组件加载也超时了，
  // 则使用加载失败时使用的组件。默认值是：`Infinity`
  timeout: 3000
})

Vue.component('async-webpack-example',AsyncComponent);
```

3. 设置resolve方法，执行`const res = factory(resolve, reject)`,由于返回的res是一个对象，res.component是一个promise对象，所以会设置` res.component.then(resolve, reject)`的回调函数
    * 如果设置了 res.error, factory.errorComp = error构造器
    * 如果设置了 res.loading, factory.loadingComp = loading构造器
        * 如果没有设置delay，直接返回factory.loadingComp
        * 否则 设置timeout，等待delay时间结束，执行`factory.loading = true;forceRender(false)`来渲染loading组件
    * 如果设置了timeout，设置timeout，等待时间结束，执行reject方法

> 由于 factory.error 的判断在 resolved之前，会直接return，所以执行了报错，就算resolve返回了结果，也不会再渲染了。


