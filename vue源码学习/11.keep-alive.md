## render 生成 vnode 时
由于keep-alive是一个组件，所以会在Vue上查找全局组建的 构造函数。

> keep-alive 组件 在初始化Vue的时候就会挂载到Vue的原型上

接着生成 keep-alive vnode

keep-alive 的使用 用到了插槽，其中的组件 在编译过程中 不会作为插槽来处理，而是直接调用 createElement方法传入组件名来生成vnode，作为 `<keep-alive>` 的子节点vnode来使用。

而一般的插槽其中 定义的 `<template>` 会生成对应的 render函数，保存在 父节点的 sloScopes字段上，在子节点渲染的过程中，通过调用相应的render函数来生成vnode

## patch 渲染出真实dom
在调用子组件的 Vue构造函数时，initRender会将 keep-alive 的子vnode（_renderChildren）挂载到 $slots上
vm.$slots = resolveSlots(options._renderChildren, renderContext);

调用 keep-alive 的 render函数
keep-alive 有两个属性用于缓存
* catch {} 保存 对应的vnode
* keys [] ,保存对应的 vnode的key，用于判断 最后使用节点

如果 该vnode未被缓存，缓存该vnode，并执行其mount方法
```js
cache[key] = vnode;
keys.push(key);

vnode.data.keepAlive = true;
```

**会生成静态节点** ？？

```js
{
    render:"with(this){return _m(0)}",
    staticRenderFns:[`with(this){return _c('div',{attrs:{"id":"childa"}},[_c('p',[_v("A")])])}`]
}
```

initComponent 将 渲染vnode上的 $el 挂载到 vue实例上

patch 最后执行 invokeInsertHook 执行 componentVNodeHooks中定义的insert方法
```js
 insert: function insert (vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }
      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          // vue-router#1212
          // During updates, a kept-alive component's child components may
          // change, so directly walking the tree here may call activated hooks
          // on incorrect children. Instead we push them into a queue which will
          // be processed after the whole patch process ended.
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true /* direct */);
        }
      }
    },
```
执行 mounted activated 钩子函数

## 更换内容

vm._render() 重新生成vnode

vm._update -> vm.patch 比较新旧vnode

patchVnode 调用 组件的 prePatch钩子函数 -> updateChildComponent

```js
var needsForceUpdate = !!(
      renderChildren ||               // has new static slots
      vm.$options._renderChildren ||  // has old static slots
      hasDynamicScopedSlot
    );


 if (needsForceUpdate) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }
```
1. 如果是一个插槽，修改 keep-alive vm实例的 vm.$options._renderChildren 为新的内容（initRender时会挂载到 $slots $slitScopes）
2. 进行强制更新，触发 keep-alive vm实例的watcher更新 在下一次nextTick进行更新
3. 再次调用 keep-alive组件的 render方法，如果缓存中没有该vnode则进行缓存
4. 在patch完成后，执行invokeInsertHook，如果是首次缓存，则调用 mounted activated钩子函数，

1. 如果 内容已经在缓存内，那么在 调用render函数时，会直接将 vm实例 挂载到 vnode.componentInstance上，（`vnode = this.$slots.default[0]`）
2. 调用 kepp-alive 的 init方法，由于此时已经存在 vnode.componentInstance,会调用
```js
var mountedNode = vnode;
componentVNodeHooks.prepatch(mountedNode, mountedNode);
```
3. 此时 needsForceUpdate = false ，不会触发强制更新