## computed
initState 的 过程中也会 对 computed属性进行初始化（initComputed）
* 会为每一个computed里的数据生成一个 watcher实例，（其中getter属性为computed中的数据由用户定义的函数或对象的get方法）与数据响应的watcher区别在与设置了lazy属性为false，这个属性主要的作用就是在数据发生改变时不会触发notify
* 将 computed中的属性 部署到 vm上，可以直接通过vm来获取，并设置其getter方法，
```js
function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate()  //计算结果 // 添加依赖
      }
      if (Dep.target) {
        watcher.depend()  // 建立 响应式数据dep 与 当前 vm的渲染watcher的联系
      }
      return watcher.value // 存值 缓存
    }
  }

function evaluate(){
    this.value = this.get()
    this.dirty = false
  }
```

* 在进行页面的渲染时 调用 render函数，会触发 计算属性的 getter方法。主要包括
    * 计算结果，其他如果包含其他响应式数据，那么会触发他们的getter方法，将计算属性的watcher添加到他们的 subs中， 计算属性的watcher的deps中也会 添加 他们的dep。
    * 建立 计算属性中所用到的 响应式数据 与 当前vm 渲染watcher的依赖关系。如果计算属性中用到其他的响应式数据，因为计算属性的没有自己的 dep对象，不能触发页面的刷新，只能通过其中响应式数据，绑定到当前的渲染watcher来进行更新。

* 如果计算属性中用到其他的响应式数据，当他们发生改变时，会通知对于的watcher更新渲染，但是如果是计算属性的watcher，因为他的lazy值是true，所以不会直接像响应式数据那样 触发 notify，而是 在其他数据触发页面重新渲染的render的时候，计算出新的值。

* 也叫做 计算属性的缓存——lazy Watcher，
  * 因为 lazy 表示一种固定描述，不可改变，表示这个 watcher 需要缓存
  * dirty 表示缓存是否可用，如果为 true，表示缓存脏了，需要重新计算，否则不用
```js
 update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true  // 不会直接进行更新
    } else if (this.sync) {   //同步
      this.run()
    } else {
      queueWatcher(this)
    }
  }

  evaluate(){
    this.value = this.get()
    this.dirty = false
  }
```

* 在2.5版本中，计算属性会对最后的计算结果与旧值进行比较，如果相同就不会触发页面的重新渲染。虽然是一种优化，但是存在问题
* 所以2.5中又去掉了这种优化

## watcher
 initWatcher 
* 执行 $watch 
* 创建一个 watcher实例， 传入 key 为 getter，value值为 callback，（传入 deep sync）
* 在创建的过程中，会调用 get 函数，触发 对 key值的解析
  * key 为 字符串 ，解析为 取值函数
  * 函数 ，直接执行
* 在取值的过程中，会触发响应式数据的 getter 方法 ，进行依赖收集，他们的subs中添加 当前 用户 watcher
* 如果此时 deep 为 true, 就会遍历对象或数组中的每一个对象，触发他们的getter，将当前 watcher 添加到他们的 subs 中

```js
//watcher.get()中
if (this.deep) {  // 深度遍历对象
        traverse(value)
      }

function _traverse (val: any, seen: SimpleSet) {
  let i, keys
  const isA = Array.isArray(val)
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }     //通过 取值 来触发 对象里的每一个属性的 getter
  if (val.__ob__) {
    const depId = val.__ob__.dep.id
    if (seen.has(depId)) {
      return
    }
    seen.add(depId)
  }
  if (isA) {
    i = val.length
    while (i--) _traverse(val[i], seen)
  } else {
    keys = Object.keys(val)
    i = keys.length
    while (i--) _traverse(val[keys[i]], seen)
  }
}
```
* 执行 $watch 会返回取消watcher的函数


* immediate 为 true ，表示立即执行 回调函数
* deep 为 true ，表示监测 对象内部属性的响应
* sync 为 true ，表示 同步执行回调 

* 在触发更新时，响应式数据抛出notify，执行 watcher的update
  * 如果此时 sync为true，会同步执行 watcher.run  即 执行 回调函数
  * 否则 将 watcher 添加到 异步队列中

* 异步执行 watcher.run ，触发回调函数，需要注意如果 deep为true，即使 value值没变，也会更新。

> 如果在回调函数中 改变其他的响应式数据，触发更新，因为此时的 渲染watcher已经在queue队列中 ，所以无需再次添加

## computed && watcher 差异
* computed是计算过程中的响应式数据数值发生变化，才会触发computed的重新计算，由于watcher没有回调函数，所以不需要将watcher加入到任务队列。 数据的重新计算也不是在触发数据的notify，而是在 render 需要使用该计算属性的时候
* watcher 根据响应式数据的变化，触发 watcher的update 方法，其中就会把当前waycher添加到队列中，等待执行其回调函数

* computed -> computed watcher -> 包含 lazy
* watcher -> user watcher -> 包含 sync immediate deep