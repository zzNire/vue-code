## 编译
[demo](./demo/slot.html)

#### 父节点
解析 template 标签 生成ast树

在ast节点添加如下属性 
* slotTarget：name
* slotTargetDynamic
* slotScope：value || `_empty_`

在 父节点的 slotScope 中添加该 template 的 ast节点

```js
if (element.slotScope) {
            // scoped slot
            // keep it in the children list so that v-else(-if) conditions can
            // find it as the prev node.
            var name = element.slotTarget || '"default"'
            ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element; //当前ast节点
          }
```
代码生成
解析写在组件中的 html标签，也就是 上文中的父节点的slotScope字段

```js
    // scoped slots
    if (el.scopedSlots) {
      data += (genScopedSlots(el, el.scopedSlots, state)) + ",";
    }
```

生成的代码：
```js
with(this){return _c('layout',{scopedSlots:_u([{key:"header",fn:function(){return [_c('h1',[_v(_s(title))])]},proxy:true},{key:"main",fn:function(){return [_c('p',[_v(_s(msg))])]},proxy:true},{key:"footer",fn:function(){return [_c('p',[_v(_s(desc))])]},proxy:true}])})}
```

```js
 if (el.slotTarget && !el.slotScope) {
      data += "slot:" + (el.slotTarget) + ",";
    }

```


#### 组件内
生成ast树

processSlotOutlet 
根据 `<slot name='name'></slot>`在ast节点上生成 
* slotName = 'name'

代码生成

genSlot方法 解析 slot标签,生成:`_t("header")`

```js
[_c('header',[_t("header")],2),_v(" "),
_c('main',[_t("main")],2),_v(" ")
,_c('footer',[_t("footer")],2)]
```

## 运行时
```js
  target._o = markOnce
  target._n = toNumber
  target._s = toString
  target._l = renderList
  target._t = renderSlot
  target._q = looseEqual
  target._i = looseIndexOf
  target._m = renderStatic
  target._f = resolveFilter
  target._k = checkKeyCodes
  target._b = bindObjectProps
  target._v = createTextVNode
  target._e = createEmptyVNode
  target._u = resolveScopedSlots
  target._g = bindObjectListeners
  target._d = bindDynamicKeys
  target._p = prependModifier
```

target._t = renderSlot

#### this.$slots

父节点在mount的过程中，执行 _u，也就是 resolveScopedSlots方法，该方法会将 slotScopes中的数组展开成一个对象

子组件在mount生成vnode的过程中，会执行 Vue._render
```js
if (_parentVnode) {
        vm.$scopedSlots = normalizeScopedSlots(
          _parentVnode.data.scopedSlots,
          vm.$slots,
          vm.$scopedSlots
        );
      }
```

将 父组件的 slotScopes 以及 slots 添加到当前 组件的 vueComponent实例中
```js
vm.$slotScopes =
{
  footer:fn(), 
  header:fn:function(){return [_c('h1',[_v(_s(title))])]},
  main:fn()
}
vm.$slots = {
  footer:[vnode],
  header:[vnode],
  main:[vnode],
}
```
fn函数就是在编译父节点过程中生成的

接着调用 子组件的 render函数 生成 vnode，在此过程中会调用 `_t("header")`,也就是 renderSlot方法

```js
var scopedSlotFn = this.$scopedSlots[name];
if(scopedSlotFn){
  nodes = scopedSlotFn(props) || fallback;
}
else{
  nodes = this.$slots[name] || fallback; 
}
```
通过调用父节点的 fn函数 来生成 vnode节点，作为子组件 调用createElement()的子节点，其中 fallback 为默认操作

其中 fn 被封装为 normalizer方法 
```js
var normalized = function () {
      var res = arguments.length ? fn.apply(null, arguments) : fn({});
      res = res && typeof res === 'object' && !Array.isArray(res)
        ? [res] // single vnode
        : normalizeChildren(res);
      return res && (
        res.length === 0 ||
        (res.length === 1 && res[0].isComment) // #9658
      ) ? undefined
        : res
    };
```

这样就实现了 父节点定义的slot 在组件中作为vnode被渲染出来


## 作用域插槽
#### 编译阶段 
对于父节点，作用域插槽 `v-slot：main='data'` 有了 value值，所以slotScope不再为空值 empty，而是 value
* slotTarget：name
* slotTargetDynamic
* slotScope：value

生成的代码会有所不同，main的fn函数 带了 data 属性，**没有proxy属性**
> 是否有proxy,依据 template生成的ast节点的 slotScope属性是否为 `_empty_`，如果是的话，proxy为true，否则为false


proxy 为false 时， vm.$slots 里不会添加该slot，是为了什么？
因为 调用该方法需要传入 一个参数，通过get方法来执行fn时 无法传入参数
```js
if (fn.proxy) {
      Object.defineProperty(normalSlots, key, {
        get: normalized,
        enumerable: true,
        configurable: true
      });
    }
```

```js
{key:"main",fn:function(data){return [_c('p',[_v(_s(data.people.name)+" + "+_s(data.text))])]}}
```

对于子组件生成ast树和代码生成都和之前差不多，就是多了一下属性
```js
_c('main',[_t("main",[_c('p',[_v(_s(people.age))])],{"people":people,"text":"hello"})],2)
```

运行时，子组件的 

在将父节点的 slotScopes 整合到 vm上时，proxy为false的 fn不会被添加到 vm.$slots上，其他字段还是相同。

`_t("main",[_c('p',[_v(_s(people.age))])],{"people":people,"text":"hello"}`,的第三个参数，把子组件的数据作为参数传给了 父节点

子组件 slot上定义的数据作为一个对象传给了 父节点的 fn函数，所以父节点可以得到子组件的数据

```js
  function renderSlot (
    name,
    fallback,
    props,
    bindObject
  ){
    var scopedSlotFn = this.$scopedSlots[name];
    nodes = scopedSlotFn(props)
  }

  function normalized(){
     fn.apply(null, arguments)
  }
```


## ??


## 总结
插槽 的 vnode生成是在 子组件渲染的时候，而不是父节点，但是子组件调用 fn方法 render函数来生成vnode 的作用域是父节点

> 对于插槽内容是组件的情况，不会生成reder函数，而是直接使用组件名来调用 createElement方法来生产 vnode，_c(tab[right_tab],{tag:"component"})