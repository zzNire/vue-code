## 补充表单知识点
#### 表单
input
* text 单行文本
    * placeholder 默认文本
* radio 单选框
    * value
    * name  单选框组名字相同
* checkbox 复选框
    * value 提交的值 

textarea 多行文本

```html
<select v-model="selected">
    <option disabled value="">请选择</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
</select>
```

* select 选择框
    * option 选项
        * value 没有的话 默认为其中文本值
        * disabled 不可选
    * multiple 多选

#### v-model修饰符
* .lazy v-model 在每次 input 事件触发后将输入框的值与数据进行同步,你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步
> input事件是在输入文本的时候触发，change事件是在input表单失去焦点时触发
* .number
* .trim

#### composition 事件
compositionstart 事件在用户开始进行非直接输入的时候触发，而在非直接输入结束，也即用户点选候选词或者点击「选定」按钮之后，会触发 compositionend 事件。

当输入一个中文时，触发顺序：
* composition start
* input
* input
* input
* composition end

compositionStart事件之后依旧要执行 input事件，如果要阻止 input事件的触发，可以使用一个boolean变量来控制。参考vue v-model 对 input标签的处理

在输入中文时，compositionend 事件在 input 事件之后触发，所以在 compositionend事件触发时，也要手动调用 input 事件处理逻辑。

#### 创建事件
```js
const e = document.createEvent('HTMLEvents')
e.initEvent(type, true, true) //决定是否事件是否应该向上冒泡
el.dispatchEvent(e)
```
* initEvent(type,bubbles,cancelable)
    * 事件类型
    * 决定是否事件是否应该向上冒泡
    * 决定该事件的默认动作是否可以被取消

* dispatchEvent 向一个指定的事件目标派发一个事件

## 编译 parse
```html
<div> 
    <input v-model="message" placeholder="edit me">   
    <p>Message is: {{ message }}</p>   
</div>
```
等同于
```html
<div> 
    <input :value="message" @input='e=>this.message=e.target.value}' placeholder="edit me">   
    <p>Message is: {{ message }}</p>   
</div>
```
v-model等相关信息都保存在 AST树节点的 attrsList 数组中。比如：`name: "v-model", value: "message"`

执行 addDirective,把 name,rawname,value包装成对象 添加到 ast节点的 **directives**属性上

## 生成代码
genData中 genDirectives -> model -> genDefaultModel

实现了对 ast节点中directives属性的代码生成

生成回调函数 `if($event.target.composing)return;message=$event.target.value`

addProps 将 message作为prop传给 value  :
`name: "value" value: "(message)"`
```js
props: Array(1)
    0:
        dynamic: undefined
        name: "value"
        value: "(message)"
```
addHandler 将回调事件添加到ats节点的 events:

```js
events:
    input:{dynamic: undefined,
        value: "if($event.target.composing)return;message=$event.target.value"}
```

vnode的data上保存了 编译过程中产生的属性，最终生成 data对象，最为createElement的第二个参数传入
```js
[_c('input',{directives:[{name:"model",rawName:"v-model",value:(message),expression:"message"}],attrs:{"placeholder":"edit me"},domProps:{"value":(message)},on:{"input":function($event){if($event.target.composing)return;message=$event.target.value}}})
```

## v-model 运行时
#### vue input 对于 中文输入的处理
patch -> createElm -> invokeCreateHooks -> updateDirectives，对data中的directives对象进行处理

insertedVnodeQueue 里添加 insert事件，触发 inserted 事件
```js
el.addEventListener('compositionstart', onCompositionStart)
el.addEventListener('compositionend', onCompositionEnd)

function onCompositionStart (e) {
  e.target.composing = true
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) return
  e.target.composing = false
  trigger(e.target, 'input')
}

function trigger (el, type) {
  const e = document.createEvent('HTMLEvents')
  e.initEvent(type, true, true)
  el.dispatchEvent(e)
}
```

所以在生产的代码中 对 input事件的回调函数是这样写的:
```js
if (needCompositionGuard) {
    code = `if($event.target.composing)return;${code}`
  }
```
其中就通过`$event.target.composing`这个值来控制input事件回调函数的触发

## components 上的 v-model
在编译的过程中会在ast节点上的data中生成 model 对象,这个data会作为 createElement的第二个参数
```js
  if (el.model) {
    data += `model:{value:${
      el.model.value
    },callback:${
      el.model.callback
    },expression:${
      el.model.expression
    }},`
  }
```
```js
model = {
    callback: "function ($$v) {message=$$v}"
    expression: ""message""
    value: "(message)"}
```

`_c('child',{model:{value:(message),callback:function ($$v) {message=$$v},expression:"message"}}`

#### 生成vnode
createElement -> createComponent，对 data中的 model对象进行处理
```js
  if (isDef(data.model)) {
    transformModel(Ctor.options, data)
  }
```
transformModel 就是把 props：value 和 input 事件添加到 组件data属性上
（data就是createElement的第二个参数）
`data.props[prop] = value`

`data.on[event] = callback`

相当于 
`<child :value='message' @input='function ($$v) {message=$$v}'></child>`

data中
* 属性 会被转化为 生产的 vnode 的 componentOptions.props
* 自定义事件 vnode.componentOptions.listeners

#### model对象
```js
let child = {
  template:`<dic id='child'>
      <input value='msg' input='updateValue' placeholder='edit me'></input>
    </div>`,
  props:['msg'],
  model:{
    prop:'msg',
    event:'change'
  },
  methods:{
    updateValue(e){
      this.$emit('change',e.target.value);
    }
  }
}
```
其中的model对象可以改变传入的prop属性名，和 触发的input事件的名字

## 组件v-model 和 表单v-model的区别
#### 表单v-model
编译在生成ast节点时，生成directives属性

在生成目标代码时，会先在 ast节点上生成
* props
* events
通过判断ast节点是否有这些属性，生成对应的代码

在运行阶段，patch过程中，**invokeCreateHooks**，分别为dom对象添加两个事件
props，events 分别由对应的 **invokeCreateHooks** 
* updateDOMProps
* updateDOMListeners
处理生成

```js
el.addEventListener('compositionstart', onCompositionStart)
el.addEventListener('compositionend', onCompositionEnd)
```
#### 组件v-model
在编译阶段 在 ast树中生成 model属性

在生成目标代码的过程中，根据model属性
```js
model = {
    callback: "function ($$v) {message=$$v}"
    expression: ""message""
    value: "(message)"}
```

在 mount的过程中，对model属性进行处理
在 data 中的 (data就是 createElement的第二个属性)
* attrs属性中生成 `value: ""`
* on属性 `input: ƒ ($$v)`

将 attrs中的属性和 组件的options 中的 props中的属性进行比较，相同就从attrs中删去

最终转变成对 props 和 events属性的处理


