## 创建响应式对象

init => initState => initData => observe => new Observer()

* 在 value 上定义 `__ob__` 属性，来保存当前数据的 Observer实例
    * 创建 Dep 对象，其中 subs 数组 来保存该数据的所有watcher
* walk 遍历 value ，为其中的每一个数据创建 Observer 实例
    * value 中的每一个属性，都执行 defineReactive => oberve() 重复上述步骤，直到value不再是一个对象或Vnode
    * 为每一个属性 defineProperty() 定义 setter getter方法

## 依赖收集
* 在创建响应式对象Observer实例，其中创建的Dep对象用来保存 data 和 watcher 之间的依赖关系
* 在渲染的过程中，生成的渲染watcher对象会在 将全局遍历Dep.targer设为自身，（在targetStack栈中保存递归调用生成的watcher） render的过程 中触发数据的 getter方法，会将当前数据的Dep实例中的 subs数组中添加 watcher （订阅者）。watcher实例中 deps数组会添加 dep 对象（用于比较 新旧 dep）
    * cleanupDeps，根据 watcher 中保存的 新旧 deps，如果新添加的dep在旧deps中不存在，就要删除 当前旧dep.subs 中的 当前watcher，这样就不会触发不必要的更新

> 为什么对于对象，配置依赖观测后，会实例化两个Dep类实例呢？
这是因为：对象，都是引用类型数据，对于引用类型数据，存在两种操作：改变引用和改变内容.

> 对象，改变引用 修改某一个属性，通过 闭包dep 来派发更新 ;对其增加 删除某一属性,通过 `__ob__` 来派发更新

> 数组，都需要通过 `__ob__` 来检测，在对数组进行响应式处理时，会修改数组原型上会改变数组自身的操作，（push，pop，splice），它们会获取到插入的值，然后把新添加的值变成一个响应式对象，在执行原先操作之后，手段派发notify通知。

一共有四个地方调用了dep.notify。

其中三个地方是调用了ob.dep.notify()。
分别是：
1. 对数组push等七个方法重写的函数中
2. set方法，为一个对象添加一个属性
3. del方法，为对象删除一个属性

而闭包中的dep.notify()只是在Object.defineProperty的set方法中触发。

那么很清楚了，#1是闭包中的Dep，用于由对象本身修改而触发setter函数导致闭包中的Dep通知所有的Watcher对象。#2则是在对象本身增删属性或者数组变化的时候被触发的Dep。

## 派发更新
* 当对数据进行更改时，会触发 setter方法，setter方法 会比较新旧值是否相同，不同则触发 dep.notify()。
* dep中的 subs数组保存着与该数据相关联的 渲染 watcher，调用watcher的update方法
* 执行 queueWatcher，将需要更新的渲染watcher保存到任务队列中（防止watcher的重复渲染），等待 nextTick时统一进行更新 flushSchedulerQueue
    * 在更新的过程中会对 watcher 的 id 从小到大排序，
        1. 因为组件是从父到子生成的
        2. 用户 watcher 总是 在 渲染 watcher 前之下的额
        3. 如果 父组件销毁，那么就不需要重新渲染子组件
    * 执行 watcher.run()

## nextTick()
\> Vue 2.6

推荐使用微任务（Promise MutationObserver ）来执行 回调函数，如果浏览器不支持，最终会使用 (setImmediate setTimeout)的形式

* 每次调用 nextTick ， 回调函数都会被存储在 callbacks数组中，只有当上一个callbacks数组执行的异步任务在事件循环中被执行（也就是执行flushCallbacks函数，将pending = false），才能执行新的callbacks数组，将异步任务添加到事件循环中的任务队列中。在此之前所有的 回调函数都会被添加到上一个callbacks数组，等待本次 tick 执行。

> $nextTick 回调函数在下一个事件循环中执行

### Vue 2.5
默认使用 微任务形式，如果浏览器不支持吗，那么使用 宏任务形式
也会对外提供  withMacroTask ，来使用宏任务形式（用于处理一些 DOM 交互事件，如 v-on 绑定的事件回调函数的处理，会强制走 macro task）

## 监听对象和数组变化的特殊情况
### 添加 删除 对象属性
Vue.set 
* 数组 -> splice -> 触发修改后的数组原生方法 -> notify
* 对象
    * 有该键值 直接修改
    * 没有 添加该属性
        * 获取该对象的 observer 对象
            * 不是响应式对象 直接返回
        * 将该属性变为响应式数据 defineReactive(ob.value, key, val) ,（在使用的时候会调用 getter 来进行赋值）
        * ob.dep.notify 手动触发更新

Vue.del
* 数组 -> splice -> 触发修改后的数组原生方法 -> notify
* 对象
    * 没有该键值 直接返回
    * 有 删除该属性
        * 获取该对象的 observer 对象
            * 不是响应式对象 直接返回
        * `delete target[key] `
        * ob.dep.notify 手动触发更新


### 修改数组内的 数据
* Vue.set  当你利用索引直接设置一个项时Vue.set(arr,index,value) 或 splice(start,1,value)
* 数组原生方法
数组，都需要通过 `__ob__` 来检测，在对数组进行响应式处理时，会修改数组原型上会改变数组自身的操作，（push，pop，splice），它们会获取到插入的值，然后把新添加的值变成一个响应式对象，在执行原先操作之后，手段派发notify通知。