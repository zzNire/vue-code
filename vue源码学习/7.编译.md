## 不同平台下的 文件的布局 和 柯里化
对于 web平台 ，运行的是 web平台下的 `entry-runtime-with-compiler`，所以该平台下的 编译生成 render 函数 的方法和 weex平台下时不同的，那么如何做到区分，就需要函数柯里化

* 编译相关的 核心公用代码 放在了 compiler 目录下 ，不同平台下的差异文件放在了 platform 文件夹下 的 web或者weex 文件夹中
* 不同的平台有不用的 配置信息，通过函数柯里化 将 配置信息 baseOptions 传入到编译 函数中保留 ，避免了还需要执行 判断平台相关的代码，提高了性能
* 利用函数柯里化技巧把baseCompile函数抽出来，把真正编译的过程和其他逻辑如对编译配置处理、缓存处理等剥离开
```js
//web
compileToFunctions(template,option) 

//web
{ compile, compileToFunctions } = createCompiler(baseOptions)

// compiler
export const createCompiler = createCompilerCreator(function baseCompile () {  
    //编译核心 
})

// compiler
export function createCompilerCreator(baseCompile) {
    return function createCompiler(baseOptions) {
        function compile() {
            const finalOptions = Object.create(baseOptions)
            const compiled = baseCompile(template.trim(), finalOptions) // 编译
            return compiled
        }
        return {
            compile,
            compileToFunctions: createCompileToFunctionFn(compile)
        }
    }
}

// compiler
export function createCompileToFunctionFn (compile){
    return function compileToFunctions () {//入口
        const compiled = compile(template, options)
        return (cache[key] = res)
    }
}

```

大概就是这么个意思

```js
// 不同平台的配置
var baseOption = {x:1};

// 核心代码
function baseCompiler(option){
    console.log(option);
}

//柯里化 生成最终的执行函数
function createCompiler(baseCompiler){
    return function compilerFn(baseOption){
        return function compiler(){
            baseCompiler.call(this,baseOption);
        }
    }
}

// 执行 编译函数
var compiler = createCompiler(baseOption)(baseCompiler);
compiler();
```

## 解析 parse 生成抽象语法树 AST